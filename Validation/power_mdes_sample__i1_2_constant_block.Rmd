---
title: "Validate_power_mdes_sample_blocked_i1_2c"
author: "Kristin Porter & Zarni Htet"
output:
  html_document:
    code_folding: hide
    df_print: paged
    fig_caption: yes
    fig_height: 8
    fig_width: 10
    highlight: monochrome
    theme: spacelab
    toc: yes
    toc_depth: 5
    toc_float: yes
  github_document:
    df_print: paged
    fig_caption: yes
    fig_height: 8
    fig_width: 10
    toc: yes
---
# Purpose

This document lays out validation steps & results for estimating statistical power, minimum detectable effect size (MDES) and sample size for 2-Level Block RCT with constant effects experimental design. We compare results of the derived methods against Monte Carlo Simulations & the PowerUp R package on power, mdes and sample size. The methods are derived by Kristin Porter as outlined in the paper/s here (Add reference section). 

### Set Up

In this section, we set up the required R packages and source files to run the rest of the Validation document.

```{r libraries, warnings = FALSE, message = FALSE}
library(RcppEigen) # Linear algebra calculations
library(snow)      # Parallelization and use of multiple clusters 
library(lme4)      # Linear mixed effect models
library(PowerUpR)  # Comparison with another package that has some limitations
library(multtest)  # Multiple Testing Procedures package
library(tictoc)    # For timing of the scripts
library(here)      # For relative path sourcing
library(pum)       # For Power Under Multiplicity Package
library(dplyr)     # For combining different dataframes
library(pander)    # For good table format
```

```{r scriptFiles, warnings = FALSE, message = FALSE}
source(here::here("Validation/Simulations", "adjust.WY.R")) # MTP Westfall-Young
source(here::here("Validation/Simulations", "gen_data_dist_2_levels.R")) # data generating functions for 2 level block and cluster
source(here::here("Validation/Simulations", "power_mcs_2_levels.R")) # Estimate power for each of the designs by running data generating function S sample times and fitting models to estimate power.
source(here::here("Validation/Simulations", "validate_power_mdes_sample_blocked_i1_2c.R")) # Wrapping and creating 
source(here::here("Validation/Simulations", "misc.R")) # For coloring texts and other purposes
```

# Power Validation

In this section, we validate power results for different definitions of power, __minimum__, __individual__ and __complete__ for three multiple adjustment multiple methods, __Bonferroni__, __Benjamini Hocheberg__ and __Holm__.

Each subsection of the power validation below is a variation of correlation between outcomes, __rho__ & the ratio of __false nulls__ in M outcomes. For more details on input parameters, please refer to the paper or the Appendix section at the bottom of this markdown.

##### M = 3,numFalse = M, J = 20, n.j  = 100, rho = (0.5, 0.5, 0.5), MDES = (0.125, 0.125, 0.125), R2 = (0,0,0)

If you are previewing this in html, please click on the code section to review more detailed parameters.

```{r rho0.5numFalseMSpecs01, warning = FALSE, message = FALSE}
# ICC needs to be zero for constant and fixed effets
design <- c("Blocked_i1_2c")
procs <- c("Bonferroni", "BH", "Holm") 
M <- 3 
MDES <- rep(0.125, M) 
rho <- c(0.5)
ncl <-2 
S = 2 # Number of samples for Monte Carlo Simulation.
B = 2 # Number of samples for WestFall-Young. The equivalent is snum in our new method.
tnum = 10000 # Number of test statistics (samples) for all procedures other than Westfall-Young. The default is set at 10,000.
J = 20 
n.j = 100 
p.j <- 0.5 
p.j.range <- rep(0.5,J) 
theta <- matrix(0,M,M) 
diag(theta) <- 0 
omega <- rep(0,M) 
Gamma.00 <- rep(0,M) 
sig.sq <- rep(1,M)
alpha <- 0.05 
ICC <- rep(0, M) 
R2.2 <- rep(0,M)  
R2.1 <- rep(0,M) 
maxT <- FALSE 
check <- FALSE # Usually for checking the code. Do not need to  
storage_path <- "./Validation/data"
validation_name <- "Blocked_i1_2c"
runSim <- TRUE
runPump <- TRUE
```

`r colorize("Individual Statistical power is estimated to be around 0.8. Please check the table below for estimations of other definitions of statistical power. Across all power definitions, estimation results across the __PUMP__ package, __Monte Carlo Simulation__ results and __PowerUp__ package are about the same as detailed below.", "green")`

`r colorize("We will be adding Westfall-Young step down adjustment later on.", "red")`

```{r rho0.5numFalseMRun02, warning = FALSE, message = FALSE}
blocked_i1_2c_compare_results <- validate_power_blocked_i1_2cfr(rho = rho, ncl = ncl, procs = procs, design = design, 
                                                                M = M, MDES = MDES,
                                                                p.j = p.j,p.j.range = p.j.range, S = S, B = B, 
                                                                tnum = tnum, J = J, 
                                                                n.j = n.j, theta = theta, omega = omega, 
                                                                Gamma.00 = Gamma.00, sig.sq = sig.sq,
                                                                alpha = alpha, ICC = ICC, R2.2 = R2.2, R2.1 = R2.1, 
                                                                maxT = maxT, rho.0_lev1 = rho.0_lev1,
                                                                rho.0_lev2 = rho.0_lev2, rho.1_lev2 = rho.1_lev2, 
                                                                check = check, storage_path = storage_path, 
                                                                validation_name = validation_name, runSim = runSim, 
                                                                runPump = runPump)

pander::pandoc.table(blocked_i1_2c_compare_results, paste0("PowerSimulation_", "rho_", rho,"_falseNull_",M), 
                     style = "grid", split.tables = 100)
```

##### M = 3,numFalse = M, J = 20, n.j  = 75, rho = (0.5, 0.5, 0.5), MDES = (0.125, 0.125, 0.125), R2 = (0,0,0)

```{r rho0.5numFalseMSpecs02, warning = FALSE, message = FALSE}
# ICC needs to be zero for constant and fixed effets
design <- c("Blocked_i1_2c")
procs <- c("Bonferroni", "BH", "Holm") 
M <- 3 
MDES <- rep(0.125, M) 
rho <- c(0.5)
ncl <-2 
S = 2 # Number of samples for Monte Carlo Simulation.
B = 2 # Number of samples for WestFall-Young. The equivalent is snum in our new method.
tnum = 10000 # Number of test statistics (samples) for all procedures other than Westfall-Young. The default is set at 10,000.
J = 20 
n.j = 75 
p.j <- 0.5 
p.j.range <- rep(0.5,J) 
theta <- matrix(0,M,M) 
diag(theta) <- 0 
omega <- rep(0,M) 
Gamma.00 <- rep(0,M) 
sig.sq <- rep(1,M)
alpha <- 0.05 
ICC <- rep(0, M) 
R2.2 <- rep(0,M)  
R2.1 <- rep(0,M) 
maxT <- FALSE 
check <- FALSE # Usually for checking the code. Do not need to  
storage_path <- "./Validation/data"
validation_name <- "Blocked_i1_2c"
runSim <- TRUE
runPump <- TRUE
```

`r colorize("Individual Statistical power is estimated to be around 0.8. Please check the table below for estimations of other definitions of statistical power. Across all power definitions, estimation results across the __PUMP__ package, __Monte Carlo Simulation__ results and __PowerUp__ package are about the same as detailed below.", "green")`

`r colorize("We will be adding Westfall-Young step down adjustment later on.", "red")`

```{r rho0.5numFalseMRun, warning = FALSE, message = FALSE}
blocked_i1_2c_compare_results <- validate_power_blocked_i1_2cfr(rho = rho, ncl = ncl, procs = procs, design = design, 
                                                                M = M, MDES = MDES,
                                                                p.j = p.j,p.j.range = p.j.range, S = S, B = B, 
                                                                tnum = tnum, J = J, 
                                                                n.j = n.j, theta = theta, omega = omega, 
                                                                Gamma.00 = Gamma.00, sig.sq = sig.sq,
                                                                alpha = alpha, ICC = ICC, R2.2 = R2.2, R2.1 = R2.1, 
                                                                maxT = maxT, rho.0_lev1 = rho.0_lev1,
                                                                rho.0_lev2 = rho.0_lev2, rho.1_lev2 = rho.1_lev2, 
                                                                check = check, storage_path = storage_path, 
                                                                validation_name = validation_name, runSim = runSim, 
                                                                runPump = runPump)

pander::pandoc.table(blocked_i1_2c_compare_results, paste0("PowerSimulation_", "rho_", rho,"_falseNull_",M), 
                     style = "grid", split.tables = 100)
```

# MDES validation

In this section, we validate the derived minimum detectable effect size function across different __MTP__ (Bonferroni, Benjamini-Hocheberg and Holms) and __power definition (individual and minimum_1).__  The validation is carried out by generating power values for the specific __MTP__ and __power__ definitions for a specific __MDES__. Then, we supply the generated estimate __power__ as an input parameter to see if the specified __MDES__ is returned.

Below is a brief description of input parameters for the __mdes__ function from the __pump__ package. For more details, please refer to the paper here [Insert Later].


## Power: 0.65 - 0.87

Below, we have input parameters of number of outcomes, minimum detectable effect size, statistical power, significance level that would estimate a high statistical power value of above __0.65__ to __1.00__ for different definitions of power. This estimated power value is used as an input to the mdes function where we validate if the _returned_ __mdes__ value is close to the __mdes__ value that was inputted to provide the estimated power.

```{r mdesCommonInputs02, message = FALSE,warning = FALSE}
M <- 3
MDES <- 0.125
numFalse <- 3
J <- 20
n.j <- 50
R2.1 <- 0.5
R2.2 <- 0
p <- 0.5
alpha <- 0.05
numCovar.1 <- 5
numCovar.2 <- NULL
rho <- 0.5
tnum <- 10000
snum <- 2000
updateProgress <- NULL
marginError <- 0.05
ICC <- 0
omega <- NULL
```


### Read the Power Table In Here



### BF Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesBonf02}
# Power generation with specifications
power_M3_BF_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "Bonferroni", MDES = MDES, 
                                                 numFalse = numFalse, J = J, n.j = n.j, 
                                                 R2.1 = R2.1, p = p, alpha = alpha, 
                                                 numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                 rho = rho,tnum = tnum, snum = snum, ncl = 8)
power_M3_BF_MDES0125 <- as.data.frame(power_M3_BF_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BF_MDES0125, style = "grid", split.tables = 90, caption = "Estimated Power Values as inputs to derived MDES function")
```

#### Individual Power

`r colorize("The Bonferroni __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the specified targetted power. The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesBonfIndiv02}
mdes_0125_bonf_indiv <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                power = power_M3_BF_MDES0125[which(power_M3_BF_MDES0125$MTP == "BF"), "indiv"],
                                                power.definition = "indiv", MTP = "BF", marginError = marginError,
                                                p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bonf_indiv <- as.data.frame(mdes_0125_bonf_indiv) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bonf_indiv$MTP <- "Bonferroni"
mdes_0125_bonf_indiv$TargettedMDES <- MDES
colnames(mdes_0125_bonf_indiv)[4] <- "Targetted MDES"
mdes_0125_bonf_indiv <- mdes_0125_bonf_indiv[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bonf_indiv, style = "grid", split.tables = 90)
```

### BH Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesBH02}
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "BH", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_BH_MDES0125 <- as.data.frame(power_M3_BH_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BH_MDES0125, style = "grid", split.tables = 90)
```
#### Individual Power

`r colorize("The Benjamini Hocheberg __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the __targetted__ individual power. The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesBHIndiv02}
mdes_0125_bh_indiv <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse, J = J, n.j = n.j, 
                                              power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"],
                                              power.definition = "indiv", MTP = "BH", marginError = marginError,
                                              p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                              R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                              rho = rho, omega = omega, tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bh_indiv <- as.data.frame(mdes_0125_bh_indiv) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bh_indiv$MTP <- "Benjamini_Hocheberg"
mdes_0125_bh_indiv$TargettedMDES <- MDES
colnames(mdes_0125_bh_indiv)[4] <- "Targetted MDES"
mdes_0125_bh_indiv <- mdes_0125_bh_indiv[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bh_indiv, style = "grid", split.tables = 90)

```

#### Minimum Power

`r colorize("The Benjamini Hocheberg __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the targetted min power. The __adjusted MDES__ is estimated at the __corresponding__ minimum power in the table below. The __corresponding__ minimum power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesBHMin102}
mdes_0125_bh_min1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse, J = J, n.j = n.j, 
                                              power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"],
                                              power.definition = "min1", MTP = "BH", marginError = marginError,
                                              p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                              R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                              rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bh_min1 <- as.data.frame(mdes_0125_bh_min1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bh_min1$MTP <- "Benjamini_Hocheberg"
mdes_0125_bh_min1$TargettedMDES <- MDES
colnames(mdes_0125_bh_min1)[4] <- "Targetted MDES"
mdes_0125_bh_min1 <- mdes_0125_bh_min1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bh_min1, style = "grid", split.tables = 90)
```

### HO Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesHO02}
power_M3_HO_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "HO", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_HO_MDES0125 <- as.data.frame(power_M3_HO_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_HO_MDES0125, style = "grid", split.tables = 90)
```

#### Individual Power

`r colorize("The Holms __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the targetted individual power. The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesHOIndiv02}
mdes_0125_holms_indiv1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                  power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"],
                                                  power.definition = "indiv", MTP = "HO", marginError = marginError,
                                                  p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                  R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                  rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_holms_indiv1 <- as.data.frame(mdes_0125_holms_indiv1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_holms_indiv1$MTP <- "Benjamini_Hocheberg"
mdes_0125_holms_indiv1$TargettedMDES <- MDES
colnames(mdes_0125_holms_indiv1)[4] <- "Targetted MDES"
mdes_0125_holms_indiv1 <- mdes_0125_holms_indiv1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_holms_indiv1, style = "grid", split.tables = 90)
```

#### Minimum Power

`r colorize("The Holms __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the targetted minimum power. The __adjusted MDES__ is estimated at the __corresponding__ minimum power in the table below. The __corresponding__ minimum power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesHOMin102}
mdes_0125_holms_min1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"],
                                                power.definition = "min1", MTP = "HO", marginError = marginError,
                                                p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_holms_min1 <- as.data.frame(mdes_0125_holms_min1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_holms_min1$MTP <- "Benjamini_Hocheberg"
mdes_0125_holms_min1$TargettedMDES <- MDES
colnames(mdes_0125_holms_min1)[4] <- "Targetted MDES"
mdes_0125_holms_min1 <- mdes_0125_holms_min1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_holms_min1, style = "grid", split.tables = 90)
```

## Power: 0.84 - 1

Below, we have input parameters of number of outcomes, minimum detectable effect size, statistical power, significance level that would estimate a moderately high statistical power value of above __0.84__ to __1__ for different definitions of power. This estimated power value is used as an input to the mdes function where we validate if the _returned_ __mdes__ value is close to the __mdes__ value that was inputted to provide the estimated power.

```{r mdesCommonInputs03, message = FALSE,warning = FALSE}
M <- 3
MDES <- 0.125
numFalse <- 3
J <- 20
n.j <- 75
R2.1 <- 0.5
R2.2 <- 0
p <- 0.5
alpha <- 0.05
numCovar.1 <- 5
numCovar.2 <- NULL
rho <- 0.5
tnum <- 10000
snum <- 2000
updateProgress <- NULL
marginError <- 0.05
ICC <- 0
omega <- NULL
```

### BF Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesBonf03}
# Power generation with specifications
power_M3_BF_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "Bonferroni", MDES = MDES, 
                                                 numFalse = numFalse, J = J, n.j = n.j, 
                                                 R2.1 = R2.1, p = p, alpha = alpha, 
                                                 numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                 rho = rho,tnum = tnum, snum = snum, ncl = 8)
power_M3_BF_MDES0125 <- as.data.frame(power_M3_BF_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BF_MDES0125, style = "grid", split.tables = 90, caption = "Estimated Power Values as inputs to derived MDES function")
```

#### Individual Power

`r colorize("The Bonferroni __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the target individual power. The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesBonfIndiv03}
mdes_0125_bonf_indiv <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                power = power_M3_BF_MDES0125[which(power_M3_BF_MDES0125$MTP == "BF"), "indiv"],
                                                power.definition = "indiv", MTP = "BF", marginError = marginError,
                                                p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bonf_indiv <- as.data.frame(mdes_0125_bonf_indiv) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bonf_indiv$MTP <- "Bonferroni"
mdes_0125_bonf_indiv$TargettedMDES <- MDES
colnames(mdes_0125_bonf_indiv)[4] <- "Targetted MDES"
mdes_0125_bonf_indiv <- mdes_0125_bonf_indiv[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bonf_indiv, style = "grid", split.tables = 90)
```

### BH Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesBH03}
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "BH", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_BH_MDES0125 <- as.data.frame(power_M3_BH_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BH_MDES0125, style = "grid", split.tables = 90)
```
#### Individual Power

`r colorize("The Benjamini Hocheberg __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the target individual power.The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesBHIndiv03}
mdes_0125_bh_indiv <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse, J = J, n.j = n.j, 
                                              power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"],
                                              power.definition = "indiv", MTP = "BH", marginError = marginError,
                                              p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                              R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                              rho = rho, omega = omega, tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bh_indiv <- as.data.frame(mdes_0125_bh_indiv) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bh_indiv$MTP <- "Benjamini_Hocheberg"
mdes_0125_bh_indiv$TargettedMDES <- MDES
colnames(mdes_0125_bh_indiv)[4] <- "Targetted MDES"
mdes_0125_bh_indiv <- mdes_0125_bh_indiv[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bh_indiv, style = "grid", split.tables = 90)

```

#### Minimum Power

`r colorize("The Benjamini Hocheberg __adjusted MDES__ and the __Target MDES__ are way off for the specified minimal power. The specified minimal power is at 1 or too close to 1 that the estimated adjusted minimum detectable effect size would be correspondingly __high__.", "red")`

```{r mdesBHMin103}
mdes_0125_bh_min1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse, J = J, n.j = n.j, 
                                              power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"],
                                              power.definition = "min1", MTP = "BH", marginError = marginError,
                                              p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                              R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                              rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bh_min1 <- as.data.frame(mdes_0125_bh_min1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bh_min1$MTP <- "Benjamini_Hocheberg"
mdes_0125_bh_min1$TargettedMDES <- MDES
colnames(mdes_0125_bh_min1)[4] <- "Targetted MDES"
mdes_0125_bh_min1 <- mdes_0125_bh_min1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bh_min1, style = "grid", split.tables = 90)
```

### HO Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesHO03}
power_M3_HO_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "HO", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_HO_MDES0125 <- as.data.frame(power_M3_HO_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_HO_MDES0125, style = "grid", split.tables = 90)
```

#### Individual Power

`r colorize("The Holms __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the target individual power.The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesHOIndiv03}
mdes_0125_holms_indiv1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                  power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"],
                                                  power.definition = "indiv", MTP = "HO", marginError = marginError,
                                                  p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                  R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                  rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_holms_indiv1 <- as.data.frame(mdes_0125_holms_indiv1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_holms_indiv1$MTP <- "Benjamini_Hocheberg"
mdes_0125_holms_indiv1$TargettedMDES <- MDES
colnames(mdes_0125_holms_indiv1)[4] <- "Targetted MDES"
mdes_0125_holms_indiv1 <- mdes_0125_holms_indiv1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_holms_indiv1, style = "grid", split.tables = 90)
```

#### Minimum Power

`r colorize("The Holms __adjusted MDES__ and the __Target MDES__ are way off for the specified minimal power. The specified minimal power is at 1 or too close to 1 that the estimated adjusted minimum detectable effect size would be correspondingly __high__.", "red")`

```{r mdesHOMin103}
mdes_0125_holms_min1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"],
                                                power.definition = "min1", MTP = "HO", marginError = marginError,
                                                p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_holms_min1 <- as.data.frame(mdes_0125_holms_min1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_holms_min1$MTP <- "Benjamini_Hocheberg"
mdes_0125_holms_min1$TargettedMDES <- MDES
colnames(mdes_0125_holms_min1)[4] <- "Targetted MDES"
mdes_0125_holms_min1 <- mdes_0125_holms_min1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_holms_min1, style = "grid", split.tables = 90)
```

## Power: 0.93 - 1

Below, we have input parameters of number of outcomes, minimum detectable effect size, statistical power, significance level that would estimate a high statistical power value of above __0.93__ to __1__ for different definitions of power. This estimated power value is used as an input to the mdes function where we validate if the _returned_ __mdes__ value is close to the __mdes__ value that was inputted to provide the estimated power.

```{r mdesCommonInputs04, message = FALSE,warning = FALSE}
M <- 3
MDES <- 0.125
numFalse <- 3
J <- 20
n.j <- 100
R2.1 <- 0.5
R2.2 <- 0
p <- 0.5
alpha <- 0.05
numCovar.1 <- 5
numCovar.2 <- NULL
rho <- 0.5
tnum <- 10000
snum <- 2000
updateProgress <- NULL
marginError <- 0.05
ICC <- 0
omega <- NULL
```

### BF Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesBonf04}
# Power generation with specifications
power_M3_BF_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "Bonferroni", MDES = MDES, 
                                                 numFalse = numFalse, J = J, n.j = n.j, 
                                                 R2.1 = R2.1, p = p, alpha = alpha, 
                                                 numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                 rho = rho,tnum = tnum, snum = snum, ncl = 8)
power_M3_BF_MDES0125 <- as.data.frame(power_M3_BF_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BF_MDES0125, style = "grid", split.tables = 90, caption = "Estimated Power Values as inputs to derived MDES function")
```

#### Individual Power

`r colorize("The Bonferroni __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the target individual power. The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesBonfIndiv04}
mdes_0125_bonf_indiv <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                power = power_M3_BF_MDES0125[which(power_M3_BF_MDES0125$MTP == "BF"), "indiv"],
                                                power.definition = "indiv", MTP = "BF", marginError = marginError,
                                                p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bonf_indiv <- as.data.frame(mdes_0125_bonf_indiv) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bonf_indiv$MTP <- "Bonferroni"
mdes_0125_bonf_indiv$TargettedMDES <- MDES
colnames(mdes_0125_bonf_indiv)[4] <- "Targetted MDES"
mdes_0125_bonf_indiv <- mdes_0125_bonf_indiv[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bonf_indiv, style = "grid", split.tables = 90)
```

### BH Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesBH04}
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "BH", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_BH_MDES0125 <- as.data.frame(power_M3_BH_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BH_MDES0125, style = "grid", split.tables = 90)
```
#### Individual Power

`r colorize("The Benjamini Hocheberg __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the target individual power. The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesBHIndiv04}
mdes_0125_bh_indiv <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse, J = J, n.j = n.j, 
                                              power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"],
                                              power.definition = "indiv", MTP = "BH", marginError = marginError,
                                              p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                              R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                              rho = rho, omega = omega, tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bh_indiv <- as.data.frame(mdes_0125_bh_indiv) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bh_indiv$MTP <- "Benjamini_Hocheberg"
mdes_0125_bh_indiv$TargettedMDES <- MDES
colnames(mdes_0125_bh_indiv)[4] <- "Targetted MDES"
mdes_0125_bh_indiv <- mdes_0125_bh_indiv[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bh_indiv, style = "grid", split.tables = 90)

```

#### Minimum Power

`r colorize("The Benjamini Hocheberg __adjusted MDES__ and the __Target MDES__ are way off for the specified minimal power. The specified minimal power is at 1 or too close to 1 that the estimated adjusted minimum detectable effect size would be correspondingly __high__.", "red")`

```{r mdesBHMin104}
mdes_0125_bh_min1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse, J = J, n.j = n.j, 
                                              power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"],
                                              power.definition = "min1", MTP = "BH", marginError = marginError,
                                              p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                              R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                              rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_bh_min1 <- as.data.frame(mdes_0125_bh_min1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_bh_min1$MTP <- "Benjamini_Hocheberg"
mdes_0125_bh_min1$TargettedMDES <- MDES
colnames(mdes_0125_bh_min1)[4] <- "Targetted MDES"
mdes_0125_bh_min1 <- mdes_0125_bh_min1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_bh_min1, style = "grid", split.tables = 90)
```

### HO Validation

In this section, we are estimating statistical powers to be inputted to the mdes function.

```{r powerMdesHO04}
power_M3_HO_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "HO", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_HO_MDES0125 <- as.data.frame(power_M3_HO_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_HO_MDES0125, style = "grid", split.tables = 90)
```

#### Individual Power

`r colorize("The Holms __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the target individual power. The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

```{r mdesHOIndiv04}
mdes_0125_holms_indiv1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                  power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"],
                                                  power.definition = "indiv", MTP = "HO", marginError = marginError,
                                                  p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                  R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                  rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_holms_indiv1 <- as.data.frame(mdes_0125_holms_indiv1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_holms_indiv1$MTP <- "Benjamini_Hocheberg"
mdes_0125_holms_indiv1$TargettedMDES <- MDES
colnames(mdes_0125_holms_indiv1)[4] <- "Targetted MDES"
mdes_0125_holms_indiv1 <- mdes_0125_holms_indiv1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_holms_indiv1, style = "grid", split.tables = 90)
```

#### Minimum Power

`r colorize("The Holms __adjusted MDES__ and the __Target MDES__ are way off for the specified minimal power. The specified minimal power is at 1 or too close to 1 that the estimated adjusted minimum detectable effect size would be correspondingly __high__.", "red")`

```{r mdesHOMin104}
mdes_0125_holms_min1 <- pum::mdes_blocked_i1_2c(M = M, numFalse = numFalse,J = J, n.j = n.j, 
                                                power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"],
                                                power.definition = "min1", MTP = "HO", marginError = marginError,
                                                p = p, alpha = alpha, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = "constant", 
                                                rho = rho, omega = omega,tnum = tnum, snum = snum, ncl = ncl)
mdes_0125_holms_min1 <- as.data.frame(mdes_0125_holms_min1) %>%
                            tibble::rownames_to_column(var = "MTP")
mdes_0125_holms_min1$MTP <- "Benjamini_Hocheberg"
mdes_0125_holms_min1$TargettedMDES <- MDES
colnames(mdes_0125_holms_min1)[4] <- "Targetted MDES"
mdes_0125_holms_min1 <- mdes_0125_holms_min1[, c(1,2,4,3)]
pander::pandoc.table(mdes_0125_holms_min1, style = "grid", split.tables = 90)
```

# Sample Validation

In this section, we validate the derived sample function. The sample function is expected to return either the __number of blocks__ or the __number of samples within the block__. Like in MDES, we validate by first generating power for a specific MTP with the block and within block sample size being specified. Then, we have the function return us either the __number of blocks__ or the __number of samples within block__ by inputting the estimated statistical power. If it returns what we originally specify to estimate statistical power then the sample function is working as it should. 

A few new input parameters are needed to test the sampling function.

* J: _the number of blocks (set to NULL if you do not want to estimate this one)_
* n.j: _the harmonic mean of blocks (set to NULL if you do not want to estimate this one)_
* J0: _the initial value for the sample number of blocks. The default is set at 10_
* n.j0: _the initial value for the harmonic mean for the number of samples within block. The default is set at 10_

Below, we have listed out input parameter setting that generated power values that would be input parameters for our derived sample function.

## Power: 0.76 - 0.87

```{r sampleCommonInputs01, message = FALSE,warning = FALSE}
M <- 3
MDES <- 0.125
numFalse <- 3
J <- 20
n.j <- 50
R2.1 <- 0.5
R2.2 <- 0
p <- 0.5
alpha <- 0.05
numCovar.1 <- 5
numCovar.2 <- NULL
rho <- 0.5
tnum <- 10000
snum <- 2000
updateProgress <- NULL
marginError <- 0.05
ICC <- 0
omega <- NULL
```

### BH Validation

```{r powerSampleBH01}
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "BH", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_BH_MDES0125 <- as.data.frame(power_M3_BH_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BH_MDES0125, style = "grid", split.tables = 90)
```

#### Indivdiual Power

##### Within Block

```{r BHWithinBlock01}
sample_BH_indiv_nj_50 <- pum::sample_blocked_i1_2c(M = M, numFalse = numFalse, MTP = "BH", typesample = "n.j", J = J, 
                                                   n.j = NULL, J0 = NULL, n.j0 = 50, MDES = MDES, 
                                                   power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"] ,
                                                   power.definition = "indiv", 
                                                   marginError = marginError, p = p,alpha = alpha,
                                                   numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                                   R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"] ))

sample_BH_indiv_nj_50$expectedSampleSize <- n.j
colnames(sample_BH_indiv_nj_50)[5] <- "Expected Sample Size"
sample_BH_indiv_nj_50 <- sample_BH_indiv_nj_50[, c(1,2,5,3,4)]
pander::pandoc.table(sample_BH_indiv_nj_50, style = "grid")
```

#### Minimum Power

##### For Blocks

```{r BHForBlocks01}
sample_BH_min1_J_20 <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "J", J = NULL, n.j = 100, 
                                            J0 = 10, n.j0 = NULL, MDES = MDES, 
                                            power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"] ,
                                            power.definition = "min1", MTP = "BH", marginError = marginError,
                                            p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                            R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"] ))

sample_BH_min1_J_20$expectedSampleSize <- J
colnames(sample_BH_min1_J_20)[5] <- "Expected Sample Size"
sample_BH_min1_J_20 <- sample_BH_min1_J_20[, c(1,2,5,3,4)]
pander::pandoc.table(sample_BH_min1_J_20, style = "grid")
```

### HO Validation

```{r powerSampleHO01}
power_M3_HO_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "HO", MDES = MDES, numFalse = numFalse, 
                                                 J = J, n.j = n.j, 
                                                 R2.1 = R2.1, p = p, alpha = alpha, 
                                                 numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                 rho = rho,tnum = tnum, snum =snum, ncl = ncl)
power_M3_HO_MDES0125 <- as.data.frame(power_M3_HO_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_HO_MDES0125, style = "grid", split.tables = 90)
```

#### Indivdiual Power

##### Within Blocks

```{r HOWithinBlocks01}
sample_HO_nj_50_indiv <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "n.j", J = 20, n.j = NULL, 
                                              J0 = NULL, n.j0 = 10, MDES = MDES, 
                                              power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"] ,
                                              power.definition = "indiv", MTP = "HO", marginError = marginError,
                                              p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                              R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"] ))

sample_HO_nj_50_indiv$expectedSampleSize <- n.j
colnames(sample_HO_nj_50_indiv)[5] <- "Expected Sample Size"
sample_HO_nj_50_indiv <- sample_HO_nj_50_indiv[, c(1,2,5,3,4)]
pander::pandoc.table(sample_HO_nj_50_indiv, style = "grid")
```

#### Minimum Power

##### For Block

```{r HOForBlock01}
sample_HO_J_20_indiv <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "J", J = NULL, n.j = 100, 
                                             J0 = 10, n.j0 = NULL, MDES = 0.125, 
                                             power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"] ,
                                             power.definition = "min1", MTP = "HO", marginError = marginError,
                                             p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                             R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)


print(paste0("We are estimating sample size for target power of ", power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"] ))

sample_HO_J_20_indiv$expectedSampleSize <- J
colnames(sample_HO_J_20_indiv)[5] <- "Expected Sample Size"
sample_HO_J_20_indiv <- sample_HO_J_20_indiv[, c(1,2,5,3,4)]
pander::pandoc.table(sample_HO_J_20_indiv, style = "grid")
```

## Power: 0.90 - 1

```{r sampleCommonInputs02, message = FALSE,warning = FALSE}
M <- 3
MDES <- 0.125
numFalse <- 3
J <- 20
n.j <- 75
R2.1 <- 0.5
R2.2 <- 0
p <- 0.5
alpha <- 0.05
numCovar.1 <- 5
numCovar.2 <- NULL
rho <- 0.5
tnum <- 10000
snum <- 2000
updateProgress <- NULL
marginError <- 0.05
ICC <- 0
omega <- NULL
```

### BH Validation

```{r powerSampleBH02}
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "BH", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_BH_MDES0125 <- as.data.frame(power_M3_BH_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BH_MDES0125, style = "grid", split.tables = 90)
```

#### Indivdiual Power

##### Within Block

```{r BHWithinBlock02}
sample_BH_indiv_nj_75 <- pum::sample_blocked_i1_2c(M = M, numFalse = numFalse, MTP = "BH", typesample = "n.j", J = J, 
                                                   n.j = NULL, J0 = NULL, n.j0 = 50, MDES = MDES, 
                                                   power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"] ,
                                                   power.definition = "indiv", 
                                                   marginError = marginError, p = p,alpha = alpha,
                                                   numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                                   R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"] ))

sample_BH_indiv_nj_75$expectedSampleSize <- n.j
colnames(sample_BH_indiv_nj_75)[5] <- "Expected Sample Size"
sample_BH_indiv_nj_75 <- sample_BH_indiv_nj_75[, c(1,2,5,3,4)]
pander::pandoc.table(sample_BH_indiv_nj_75, style = "grid")
```

#### Minimum Power

##### For Blocks

```{r BHForBlocks02}
sample_BH_min1_J_20 <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "J", J = NULL, n.j = 100, 
                                            J0 = 10, n.j0 = NULL, MDES = MDES, 
                                            power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"] ,
                                            power.definition = "min1", MTP = "BH", marginError = marginError,
                                            p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                            R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"] ))

sample_BH_min1_J_20$expectedSampleSize <- J
colnames(sample_BH_min1_J_20)[5] <- "Expected Sample Size"
sample_BH_min1_J_20 <- sample_BH_min1_J_20[, c(1,2,5,3,4)]
pander::pandoc.table(sample_BH_min1_J_20, style = "grid")
```

### HO Validation

```{r powerSampleHO02}
power_M3_HO_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "HO", MDES = MDES, numFalse = numFalse, 
                                                 J = J, n.j = n.j, 
                                                 R2.1 = R2.1, p = p, alpha = alpha, 
                                                 numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                 rho = rho,tnum = tnum, snum =snum, ncl = ncl)
power_M3_HO_MDES0125 <- as.data.frame(power_M3_HO_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_HO_MDES0125, style = "grid", split.tables = 90)
```

#### Indivdiual Power

##### Within Blocks

```{r HOWithinBlocks02}
sample_HO_nj_75_indiv <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "n.j", J = 20, n.j = NULL, 
                                              J0 = NULL, n.j0 = 10, MDES = MDES, 
                                              power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"] ,
                                              power.definition = "indiv", MTP = "HO", marginError = marginError,
                                              p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                              R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"] ))

sample_HO_nj_75_indiv$expectedSampleSize <- n.j
colnames(sample_HO_nj_75_indiv)[5] <- "Expected Sample Size"
sample_HO_nj_75_indiv <- sample_HO_nj_75_indiv[, c(1,2,5,3,4)]
pander::pandoc.table(sample_HO_nj_75_indiv, style = "grid")
```

#### Minimum Power

##### For Block

```{r HOForBlock02}
sample_HO_J_20_indiv <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "J", J = NULL, n.j = 100, 
                                             J0 = 10, n.j0 = NULL, MDES = 0.125, 
                                             power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"] ,
                                             power.definition = "min1", MTP = "HO", marginError = marginError,
                                             p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                             R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"] ))

sample_HO_J_20_indiv$expectedSampleSize <- J
colnames(sample_HO_J_20_indiv)[5] <- "Expected Sample Size"
sample_HO_J_20_indiv <- sample_HO_J_20_indiv[, c(1,2,5,3,4)]
pander::pandoc.table(sample_HO_J_20_indiv, style = "grid")
```

## Power: 0.95-1

```{r sampleCommonInputs03, message = FALSE,warning = FALSE}
M <- 3
MDES <- 0.125
numFalse <- 3
J <- 20
n.j <- 100
R2.1 <- 0.5
R2.2 <- 0
p <- 0.5
alpha <- 0.05
numCovar.1 <- 5
numCovar.2 <- NULL
rho <- 0.5
tnum <- 10000
snum <- 2000
updateProgress <- NULL
marginError <- 0.05
ICC <- 0
omega <- NULL
```

### BH Validation

```{r powerSampleBH03}
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "BH", MDES = MDES, numFalse = numFalse, J = J, n.j = n.j, 
                                                  R2.1 = R2.1, p = p, alpha = alpha, numCovar.1 = numCovar.1, 
                                                  numCovar.2 = numCovar.2,
                                                  rho = rho,tnum = tnum, snum = snum, ncl = ncl)
power_M3_BH_MDES0125 <- as.data.frame(power_M3_BH_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_BH_MDES0125, style = "grid", split.tables = 90)
```

#### Indivdiual Power

##### Within Block

```{r BHWithinBlock03}
sample_BH_indiv_nj_100 <- pum::sample_blocked_i1_2c(M = M, numFalse = numFalse, MTP = "BH", typesample = "n.j", J = J, 
                                                   n.j = NULL, J0 = NULL, n.j0 = 50, MDES = MDES, 
                                                   power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"] ,
                                                   power.definition = "indiv", 
                                                   marginError = marginError, p = p,alpha = alpha,
                                                   numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                                   R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "indiv"] ))

sample_BH_indiv_nj_100$expectedSampleSize <- n.j
colnames(sample_BH_indiv_nj_100)[5] <- "Expected Sample Size"
sample_BH_indiv_nj_100 <- sample_BH_indiv_nj_100[, c(1,2,5,3,4)]
pander::pandoc.table(sample_BH_indiv_nj_100, style = "grid")
```

#### Minimum Power

##### For Blocks

```{r BHForBlocks03}
sample_BH_min1_J_20 <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "J", J = NULL, n.j = 100, 
                                            J0 = 10, n.j0 = NULL, MDES = MDES, 
                                            power = power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"] ,
                                            power.definition = "min1", MTP = "BH", marginError = marginError,
                                            p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                            R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_BH_MDES0125[which(power_M3_BH_MDES0125$MTP == "BH"), "min1"] ))

sample_BH_min1_J_20$expectedSampleSize <- J
colnames(sample_BH_min1_J_20)[5] <- "Expected Sample Size"
sample_BH_min1_J_20 <- sample_BH_min1_J_20[, c(1,2,5,3,4)]
pander::pandoc.table(sample_BH_min1_J_20, style = "grid")
```

### HO Validation

```{r powerSampleHO03}
power_M3_HO_MDES0125 <- pum::power_blocked_i1_2c(M = M, MTP = "HO", MDES = MDES, numFalse = numFalse, 
                                                 J = J, n.j = n.j, 
                                                 R2.1 = R2.1, p = p, alpha = alpha, 
                                                 numCovar.1 = numCovar.1, numCovar.2 = numCovar.2,
                                                 rho = rho,tnum = tnum, snum =snum, ncl = ncl)
power_M3_HO_MDES0125 <- as.data.frame(power_M3_HO_MDES0125) %>%
                            tibble::rownames_to_column(var = "MTP")
pander::pandoc.table(power_M3_HO_MDES0125, style = "grid", split.tables = 90)
```

#### Indivdiual Power

##### Within Blocks

```{r HOWithinBlocks03}
sample_HO_nj_100_indiv <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "n.j", J = 20, n.j = NULL, 
                                              J0 = NULL, n.j0 = 10, MDES = MDES, 
                                              power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"] ,
                                              power.definition = "indiv", MTP = "HO", marginError = marginError,
                                              p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                              R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "indiv"] ))

sample_HO_nj_100_indiv$expectedSampleSize <- n.j
colnames(sample_HO_nj_100_indiv)[5] <- "Expected Sample Size"
sample_HO_nj_100_indiv <- sample_HO_nj_100_indiv[, c(1,2,5,3,4)]
pander::pandoc.table(sample_HO_nj_100_indiv, style = "grid")
```

#### Minimum Power

##### For Block

```{r HOForBlock03}
sample_HO_J_20_indiv <- sample_blocked_i1_2c(M = M, numFalse = numFalse, typesample = "J", J = NULL, n.j = 100, 
                                             J0 = 10, n.j0 = NULL, MDES = 0.125, 
                                             power = power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"] ,
                                             power.definition = "min1", MTP = "HO", marginError = marginError,
                                             p = p,alpha = alpha,numCovar.1 = numCovar.1,numCovar.2 = numCovar.2,
                                             R2.1 = R2.1,tnum = tnum, snum = snum, ncl = ncl)

print(paste0("We are estimating sample size for target power of ", power_M3_HO_MDES0125[which(power_M3_HO_MDES0125$MTP == "HO"), "min1"] ))

sample_HO_J_20_indiv$expectedSampleSize <- J
colnames(sample_HO_J_20_indiv)[5] <- "Expected Sample Size"
sample_HO_J_20_indiv <- sample_HO_J_20_indiv[, c(1,2,5,3,4)]
pander::pandoc.table(sample_HO_J_20_indiv, style = "grid")
```

### Appendix:

#### Input parameters for Power:

* **design**: _the research design of interest: blocked_i1_2c, blocked_i1_2f, blocked_i1_2r_ 
* **procs**: _multiple adjustment procedures such as Bonferroni, Benjamini-Hocheberg, Holms_
* **M**: _number of outcomes_
* **MDES**: _minimum detectable effect size_
* **rho**: _spearman correlation (monotonic (not necessarily linear) relationship) between outcomes_
* **ncl**: _number of clusters to run parallel computation on your machine/server_
* **S**: _number of samples for Monte Carlo Simulation of Power Estimation_ 
* **B**: _number of samples for WestFall-Young MTP. The equivalent is snum in our method_
* **tnum**: _number of test statistics (samples) for all procedures other than West-Fall Young. The default is set at 10,000_
* **J**: _number of blocks_ 
* **n.j**: _number of samples within a block_
* **p.j**: _probability of being assigned to treatment when no blocking_ 
* **p.j.range**: _vector of minimum and maximum probabilities of being assigned to treatment, across all sites_
* **theta**: _MxM matrix of correlations between residuals in Level 2 model outcomes under no treatment and Level 2_
* **omega**: _effect size variability, between 0 and 1, 0 if no variation in effects across blocks, vector length M_
* **Gamma.00**: _grand mean outcome w/o treat, held 0, vector length M_
* **sig.sq**: _vector length M, held at 1 for no_
* **alpha**: _the significance level, 0.05 usually_
* **ICC**: _a number, intraclass correlation; 0 if fixed model_
* **R2.2**: _a vector of length M corresponding to R^2 for M outcomes of Level 2 (R^2 = variation in the data explained by the model)_
* **R2.1**: _a vector of length M corresponding to R^2 for M outcomes of Level 1 (R^2 = variation in the data explained by the model)_
* **maxT**: _?_
* **check**: _checking to see if intermeidate outputs are as expected_
* **storage_path**: _file path to store the validation results_
* **validation_name**: _name of the validation file_
* **runSim**: _if TRUE, we will re-run the simluation. if FALSE, we will pull previous run result_
* **runPump**: _if TRUE, we will run method from our package. if FALSE, we will pull previous run result_

#### Input parameters for MDES:

* **M**: _the number of hypothesis tests (outcomes)._
* **numFalse**: _the number of false nulls. This parameter is used for non-Shiny calculations._
* **J**: _the number of blocks._
* **n.j**: _the harmonic mean of the number of units per block._
* **power**: _required statistical power for the experiment._
* **power.definition**: _definition of statistical power from individual, d-minimal to complete power._
* **MTP**: _type of multiple testing procedure._
* **marginError**: _the margin of error for MDES estimation based on targeted power value._
* **p**: _the proportion of samples that are assigned to the treatment._
* **alpha**: _the family wise error rate (FWER)._
* **numCovar.1**: _number of Level 1 baseline covariates (not including block dummies)._
* **numCovar.2**: _number of Level 2 baseline covariates (set to 0 for this design)._
* **R2.1**: _a vector of length M corresponding to R^2 for M outcomes of Level 1 (R^2 = variation in the data explained by the model)_ 
* **R2.2**: _a vector of length M corresponding to R^2 for M outcomes of Level 2 (R^2 = variation in the data explained by the model)._ 
* **ICC**: _intraclass correlation._
* **mod.type**: _"c" for constant effects, "f" for fixed effects, "r" for random effects (parameter not in use at the moment)._ 
* **sigma**: _correlation matrix for correlations between test statistics (parameter not in use at the moment.Default is set to 0.99)_
* **rho**: _correlation between outcomes. This generates the sigma matrix._
* **omega**: _NULL (parameter in development)_
* **tnum**: _the number of test statistics (samples) for all procedures other than Westfall-Young & number of permutations for WY. The default is set at 10,000._
* **snum**: _the number of samples for Westfall-Young. The default is set at 1,000._
* **ncl**: _ncl the number of clusters to use for parallel processing. The default is set at 2._
* **updateProgress**: _this is the progress bar function that will be passed to the main MDES calculation function._
