---
title: "Profiling code speed"
date: 02/05/2019
output: pdf_document
---

## Loading the blockrct2_power.R file

```{r}
source("blockrct2_power.R")
#library(pum)
```
## Parameters for testing power function en masse

The initial conditions for power are set as below. These are initial conditions set of a vector of length 5 that would allow us to use expand grid to test out all different combinations of scenarios.

```{r}
M <- c(5:10)
MDES <- seq(from = 0.125, to = 0.1, length.out = 5 )
Aimpacts <- seq(from = 5, to = 1, length.out = 5)
J <- seq(10, 50, length.out = 5)
n.j <- seq(50,100, length.out = 5)
R2.1 <- seq(0.4, 0.9, length.out = 5)
p <- 0.5
alpha <- 0.05
numCovar.1 <- c(5:10)
```

## Test Cases before implmenting optimization

### Summary for power function speed profiles

The key drivers of computational time are Westfall-Young Single Step and Westfall-Young Step Down procedures within the power function.

* Increasing the baseline parameters other than sample number (snum) are not going to significantly change the computational time.

* Increasing snum, however, affects computational time significantly to as much as 3 minutes per power calculation should we want to calculate base on set initial conditions.

* Parallelization appears to be working as WestFall-Young Step Down and Westfall-Young Single Step takes about the same time. By code design, WYSD has an additional loop structure going compared to WYSS. In other words, you have an additional N computational time.

* Increasing the number of clusters do not decrease the speed of computation.

### Test case 1 for Power

An initial test case with a **baseline** parameters set as below. The total elapsed time for the computation is **5.4** seconds. 
The majority of the time is spent on apply function using multtest's built in function to find adjustments for all the MTPs except Westfall-Young at 2.2 seconds. The rest is split in over 1 seconds each with Westfall-Young SD and Westfall-Young Single Step. Sample number for Westfall-Young is set at 10.

* M = 5
* MDES = 0.125
* Ai = 3
* J = 10
* n.j = 10
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 10
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 5, MDES = 0.125, Ai = 3 , J = 10 , n.j = 10, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 10, updateProgress = NULL)
```

### Test case 2 for Power

Here the **baseline** parameters of the harmonic mean is made 10 times compared to in test case 1. The number of M outcomes is made twice the original set amount of 5, too. The total elapsed time for the computation is ~ **8** seconds. 
Again, the majority of the time is spent on apply function using multtest's built in function to find adjustments for all the MTPs except Westfall-Young at ~ 3 seconds. We see increases in both Westfall-Young SD and Westfall-Young SS, too with more time allocated towards WYSD.

* M = 10
* MDES = 0.125
* Ai = 3
* J = 10
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 10
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 10 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 10, updateProgress = NULL)
```

### Test case 3 for Power

In test case 3, we go back to the baseline conditions for all the parameters except the number of sample as it applies to Westfall-Young. The target number of samples stands at 1,000 but, currently, we have increased it by **10** times to **1,00** from **10**.

This leads to a significant increase in the computation time up to **22** seconds from the original **5.4** seconds.We are seeing an increase of about **4** times. The allocation across programming pieces have also shifted towards Westfall-Young procedures taking the balk of it at **10** and **9** seconds each with not much in the multtest procedure. 

* M = 5
* MDES = 0.125
* Ai = 3
* J = 10
* n.j = 10
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 100
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 10 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 100, updateProgress = NULL)
```

### Test case 4 for Power

In test case 4, we have increased some of the baseline parameters such as M, J and n.j. Additionally, we doubled the number of samples for Westfall-Young from 100 to 200, a doubling. With this, we are seeing a further increase in computation time of up to **37** seconds with a non-linear increase in Westfall-Young procedure of up to **16** seconds each.

* M = 10
* MDES = 0.125
* Ai = 3
* J = 50
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 200
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 10 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 200, updateProgress = NULL)
```


### Test case 5 for Power

In test case 5, we have maintained the same parameters as before except the sample for Westfall-Young is increased from 200 to 500. With this, we see a significant increase in computation time of up to **86** (i.e 1 minute and 26) seconds. The majority of the time elapsed increase could be contributed as before to Westfall-Young procedures each clocking **40** seconds.

* M = 10
* MDES = 0.125
* Ai = 3
* J = 50
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 500
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 50 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 500, updateProgress = NULL)
```

### Test case 6 for Power

In test case 6, we change the number of clusters used to run the power calculation from 2 to 4. The goal was to see whether with increased cluster, we see a decline in computational time. On the contrary, we don't. The computational time increases in fact by **2** seconds to **88** (i.e 1 minute 20 seconds) seconds. More runs are needed to confirm whether there is a statistical fluke or not.

* M = 10
* MDES = 0.125
* Ai = 3
* J = 50
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 500
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 50 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 500, updateProgress = NULL)
```

### Test case 7 for Power

Number of clusters is back to 2 but, the sample number for Westfall-Young is doubled further to the minimum a thousand that is required for a good run of Westfall-Young. All the other parameters remain the same. Doubling than the number of sample size leads to more than a doubling of computation time at **3** minutes. 

* M = 10
* MDES = 0.125
* Ai = 3
* J = 50
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 1000
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 50 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 1000, updateProgress = NULL)
```

## Summary for MDES speed profiles





### Test case 1 for MDES-BH-indiv speed profile

In test case 1 for MDES of Benjamini Hocheberg, we have the baseline parameters of 5 outcomes, 10 blocks, a harmonic mean of 10.
We have set the statistical power to be at 0.75 with the power definition set. The total computation time turns out to be at approximately **21.5** seconds.

* M_mdes = 5
* Aimpact_mdes = 3
* J_mdes = 10
* n.j_mdes = 10
* power_mdes = 0.75
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 10
* power.definition = indiv


```{r}
MDES.blockedRCT.2(M = 5, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 10, power = 0.75, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 10, ncl = 2, updateProgress = NULL)
```

### Test case 2 for MDES-BH-indiv speed profile

Here we increase the harmoninc mean to 100. The elapsed time for computing MDES increases by 5 seconds to approximately **28** seconds.

* M_mdes = 10
* Aimpact_mdes = 3
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.75
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 10
* power.definition = indiv


```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.75, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 10, ncl = 2, updateProgress = NULL)
```

### Test case 3 for MDES-BH-indiv speed profile

Here compared to test case 2, we increase the number of samples to **1000**. The time elapsed increases by barely **1** second to **29.5** seconds.

* M_mdes = 10
* Aimpact_mdes = 3
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.75
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv


```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.75, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```

### Test case 4 for MDES-BH-indiv speed profile

Here compared to test 3, we decreased the statistical power to **0.5** from **0.75**. The time elapsed again inched up by approximately **1** seconds to **30** seconds.

* M_mdes = 10
* Aimpact_mdes = 3
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv


```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```

### Test case 5 for MDES-BH-indiv speed profile

Here compared to test 4, we increase the actual impact of MDES to 10 from 3. The time elapsed actually goes back down by 1.5 seconds to **28.5** seconds.

* M_mdes = 10
* Aimpact_mdes = 10
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv

```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```

### Test case 6 for MDES-BH-indiv speed profile

In this test case, changed the definition of power from individual to 1-minimal. The time elapsed to get an estimate of the MDES within the range is **37.5** seconds after **5** iterations of binary search. 

* M_mdes = 10
* Aimpact_mdes = 10
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = min-1
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = min1

```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "min1", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```
### Test case 7-8-9 for MDES-BH-indiv speed profile

In test case 7, we changed the definition of power from min1 (1-minimal power) to complete power. We increased the number of iterations to search for the optimal MDES to 25, 40 (program crashes and run out of memory). At 25. we cpi;d mpt get a satisfactory BH answer.

First run of complete power does not result in a returned result. It looks like within 20 iterations, I could not get the optimal
MDES for the given margin of error and power. For the next run, I increase the iteration number to 40. The whole program crashes.

In fact, I further cleared the power and ran up to 45 for both BF and BH. Neither returns a satisfactory MDES.


* M_mdes = 10
* Aimpact_mdes = 10
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = complete
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv

```{r}
mdes.complete <- MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "complete", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```
### Test case 10 for MDES-Holms-indiv speed profile


Continue on Holm test tmr.

Run for complete power for up to 45 iterations across M = 5 and 10 and still not returning a result for both BF and BH

* M_mdes = 10
* Aimpact_mdes = 10
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = complete
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv

```{r}
mdes.complete <- MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "indiv", MTP = "HO", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```











