---
title: "Profiling code speed"
date: 02/05/2019
output: pdf_document
---

## Loading the blockrct2_power.R file

```{r}
source("blockrct2_power.R")
#library(pum)
```
## Parameters for testing power function en masse

The initial conditions for power are set as below. These are initial conditions set of a vector of length 5 that would allow us to use expand grid to test out all different combinations of scenarios.

```{r}
M <- c(5:10)
MDES <- seq(from = 0.125, to = 0.1, length.out = 5 )
Aimpacts <- seq(from = 5, to = 1, length.out = 5)
J <- seq(10, 50, length.out = 5)
n.j <- seq(50,100, length.out = 5)
R2.1 <- seq(0.4, 0.9, length.out = 5)
p <- 0.5
alpha <- 0.05
numCovar.1 <- c(5:10)
```

## Test Cases before implmenting optimization

### Summary for power function speed profiles

The key drivers of computational time are Westfall-Young Single Step and Westfall-Young Step Down procedures within the power function.

* Increasing the baseline parameters other than sample number (snum) are not going to significantly change the computational time.

* Increasing snum, however, affects computational time significantly to as much as 3 minutes per power calculation should we want to calculate base on set initial conditions.

* Parallelization appears to be working as WestFall-Young Step Down and Westfall-Young Single Step takes about the same time. By code design, WYSD has an additional loop structure going compared to WYSS. In other words, you have an additional N computational time.

* Increasing the number of clusters do not decrease the speed of computation.

### Test case 1 for Power

An initial test case with a **baseline** parameters set as below. The total elapsed time for the computation is **5.4** seconds. 
The majority of the time is spent on apply function using multtest's built in function to find adjustments for all the MTPs except Westfall-Young at 2.2 seconds. The rest is split in over 1 seconds each with Westfall-Young SD and Westfall-Young Single Step. Sample number for Westfall-Young is set at 10.

* M = 5
* MDES = 0.125
* Ai = 3
* J = 10
* n.j = 10
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 10
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 5, MDES = 0.125, Ai = 3 , J = 10 , n.j = 10, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 10, updateProgress = NULL)
```

### Test case 2 for Power

Here the **baseline** parameters of the harmonic mean is made 10 times compared to in test case 1. The number of M outcomes is made twice the original set amount of 5, too. The total elapsed time for the computation is ~ **8** seconds. 
Again, the majority of the time is spent on apply function using multtest's built in function to find adjustments for all the MTPs except Westfall-Young at ~ 3 seconds. We see increases in both Westfall-Young SD and Westfall-Young SS, too with more time allocated towards WYSD.

* M = 10
* MDES = 0.125
* Ai = 3
* J = 10
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 10
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 10 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 10, updateProgress = NULL)
```

### Test case 3 for Power

In test case 3, we go back to the baseline conditions for all the parameters except the number of sample as it applies to Westfall-Young. The target number of samples stands at 1,000 but, currently, we have increased it by **10** times to **1,00** from **10**.

This leads to a significant increase in the computation time up to **22** seconds from the original **5.4** seconds.We are seeing an increase of about **4** times. The allocation across programming pieces have also shifted towards Westfall-Young procedures taking the balk of it at **10** and **9** seconds each with not much in the multtest procedure. 

* M = 5
* MDES = 0.125
* Ai = 3
* J = 10
* n.j = 10
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 100
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 10 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 100, updateProgress = NULL)
```

### Test case 4 for Power

In test case 4, we have increased some of the baseline parameters such as M, J and n.j. Additionally, we doubled the number of samples for Westfall-Young from 100 to 200, a doubling. With this, we are seeing a further increase in computation time of up to **37** seconds with a non-linear increase in Westfall-Young procedure of up to **16** seconds each.

* M = 10
* MDES = 0.125
* Ai = 3
* J = 50
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 200
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 10 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 200, updateProgress = NULL)
```


### Test case 5 for Power

In test case 5, we have maintained the same parameters as before except the sample for Westfall-Young is increased from 200 to 500. With this, we see a significant increase in computation time of up to **86** (i.e 1 minute and 26) seconds. The majority of the time elapsed increase could be contributed as before to Westfall-Young procedures each clocking **40** seconds.

* M = 10
* MDES = 0.125
* Ai = 3
* J = 50
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 500
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 50 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 500, updateProgress = NULL)
```

### Test case 6 for Power

In test case 6, we change the number of clusters used to run the power calculation from 2 to 4. The goal was to see whether with increased cluster, we see a decline in computational time. On the contrary, we don't. The computational time increases in fact by **2** seconds to **88** (i.e 1 minute 20 seconds) seconds. More runs are needed to confirm whether there is a statistical fluke or not.

* M = 10
* MDES = 0.125
* Ai = 3
* J = 50
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 500
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 50 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 500, updateProgress = NULL)
```

### Test case 7 for Power

Number of clusters is back to 2 but, the sample number for Westfall-Young is doubled further to the minimum a thousand that is required for a good run of Westfall-Young. All the other parameters remain the same. Doubling than the number of sample size leads to more than a doubling of computation time at **3** minutes. 

* M = 10
* MDES = 0.125
* Ai = 3
* J = 50
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* ICC = NULL
* tnum = 10000
* snum = 1000
* updateProgress = NULL

```{r}
power.blockedRCT.2(M = 10, MDES = 0.125, Ai = 3 , J = 50 , n.j = 100, R2.1 = 0.5 , p = 0.5 , alpha = 0.05 , numCovar.1 = 5 , numCovar.2 = NULL, ICC = NULL, tnum = 10000, snum = 1000, updateProgress = NULL)
```

## Summary for MDES speed profiles

### Test case 1 for MDES-BH-indiv speed profile

* M_mdes = 5
* Aimpact_mdes = 3
* J_mdes = 10
* n.j_mdes = 10
* power_mdes = 0.75
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 10
* power.definition = indiv


```{r}
MDES.blockedRCT.2(M = 5, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 10, power = 0.75, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 10, ncl = 2, updateProgress = NULL)
```

### Test case 2 for MDES-BH-indiv speed profile

* M_mdes = 10
* Aimpact_mdes = 3
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.75
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 10
* power.definition = indiv


```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.75, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 10, ncl = 2, updateProgress = NULL)
```

### Test case 3 for MDES-BH-indiv speed profile

* M_mdes = 10
* Aimpact_mdes = 3
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.75
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv


```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.75, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```

### Test case 4 for MDES-BH-indiv speed profile

power = 0.5 from 0.75

* M_mdes = 10
* Aimpact_mdes = 3
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv


```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```

### Test case 5 for MDES-BH-indiv speed profile

power = 0.5 from 0.75
Aimpact_mdes is adjusted up to 10 from 3.

* M_mdes = 10
* Aimpact_mdes = 10
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = indiv
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv

```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "indiv", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```

### Test case 6 for MDES-BH-indiv speed profile

power = 0.5 from 0.75
Aimpact_mdes is adjusted up to 10 from 3.
Change power definition from individual to min1.

First run of complete power does not result in a returned result. It looks like within 20 iterations, I could not get the optimal
MDES for the given margin of error and power. For the next run, I increase the iteration number to 40. The whole program crashes.

In these test cases, we are adjusting the number of iterations to see how far we can pushed until we run out of memory.
25 iterations gave us a statisfactory BH answer.

* M_mdes = 10
* Aimpact_mdes = 10
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = min-1
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv

```{r}
MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "min1", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```
### Test case 7 for MDES-BH-indiv speed profile

Run for complete power for up to 45 iterations across M = 5 and 10 and still not returning a result for both BF and BH

* M_mdes = 10
* Aimpact_mdes = 10
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = complete
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv

```{r}
mdes.complete <- MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "complete", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```
### Test case 7 for MDES-Holms-indiv speed profile

Run for complete power for up to 45 iterations across M = 5 and 10 and still not returning a result for both BF and BH

* M_mdes = 10
* Aimpact_mdes = 10
* J_mdes = 10
* n.j_mdes = 100
* power_mdes = 0.5
* pdefn_mdes = complete
* MTP_mdes = BH
* me_mdes = 0.05
* p_mdes = 0.5
* alpha_mdes = 0.05
* numCovar.1_mdes = 5
* R2.1_mdes = 0.5
* tnum = 10000
* snum = 1000
* power.definition = indiv

```{r}
mdes.complete <- MDES.blockedRCT.2(M = 10, numFalse = 5, Ai_mdes = 3, J = 10, n.j = 100, power = 0.5, power.definition = "complete", MTP = "BH", marginError = 0.05, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL, R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", omega = NULL,tnum = 10000, snum = 1000, ncl = 2, updateProgress = NULL)
```











