---
title: "Verification for 2-Level Blocked RCT with Constant Effects"
author: "Deni Chen"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: github_document:
    toc: true
    toc_float: true
    number_sections: true
    #theme: cerulean
---

# Set up

```{r}
#this is validation template was created before we migrated power calculations to the pum package
library(yaml)
library(knitr)
library(kableExtra)
library(PowerUpR)
library(pum)
library(plyr)

#read in configs file
configs <- yaml.load_file("configs.yaml")

#set directory for reading in files
fdir <- configs$fdir
```


# Load power calculation matrices from the simulations

```{r}
simpwr0 <- "Blocked_i1_2cM6n.j100J20ICC0MDES0.125rho0_S2000B10000_R2.10_R2.20_simpwr.Rda"
simpwr.2 <- "Blocked_i1_2cM6n.j100J20ICC0MDES0.125rho0.2_S2000B10000_R2.10_R2.20_simpwr.Rda"
simpwr.5 <- "Blocked_i1_2cM6n.j100J20ICC0MDES0.125rho0.5_S2000B10000_R2.10_R2.20_simpwr.Rda"
simpwr.8 <- "Blocked_i1_2cM6n.j100J20ICC0MDES0.125rho0.8_S2000B10000_R2.10_R2.20_simpwr.Rda"

simpwr.cor0 = local(get(load(paste0(fdir, simpwr0))))
simpwr.cor.2 = local(get(load(paste0(fdir, simpwr.2))))
simpwr.cor.5 = local(get(load(paste0(fdir, simpwr.5))))
simpwr.cor.8 = local(get(load(paste0(fdir, simpwr.8))))

#add data frames to a list to process it altogether
list_of_simpwr <- list(simpwr.cor0, simpwr.cor.2, simpwr.cor.5, simpwr.cor.8)

#add a correlation column to the data files
corrlist <- c(0, .2,.5,.8)
mtplist <- c("rawp", "BF", "BH", "HO", "WY-SD")

simpwr.c <- Map(cbind, list_of_simpwr, corr=corrlist)

#set up function to get mtps into col
rowtocolumn <- function(df){
  df$mtp <- row.names(df)
  return(df$mtp)
}

#add mtps to cols
listmtps <- lapply(simpwr.c, rowtocolumn)
simpwr.b <- mapply(cbind, simpwr.c, 'mtp' = listmtps, SIMPLIFY = F)

#bind sim tables
MCmethods <- ldply(simpwr.b, data.frame)

```


# Pull in our power calculations (via the pum package)
```{r}
#set parameters for function
M <- 6
MDES <- 0.125
Ai <- 6
J <- 20
n.j <- 100
p <- 0.5
alpha <- 0.05
numCovar.1 <- 0
numCovar.2 <- 0
R2.1 <- 0 
R2.2 <- 0 
ICC <- 0 
mod.type <- 'c'
omega <- 0
tnum <- 10000
snum <- 1000
ncl <- 2
updateProgress <- NULL
sigma <- 0

#generate matrices

## NOTE: sigma is a matrix of row currently (line 232 on pump repo)

#corr = 0
power.corr0 <- power.blockedRCT.2(M=M, MDES=MDES, Ai=Ai, J=J, n.j=n.j, p=p,                alpha=alpha, numCovar.1=numCovar.1, numCovar.2 = numCovar.2,                R2.1=R2.1, R2.2=R2.2, ICC=ICC, mod.type = mod.type, 
               sigma = sigma,
               rho = 0, omega = omega, tnum = tnum, snum = snum, ncl = ncl,
               updateProgress = updateProgress)

#corr = 0.2
power.corr0.2 <- power.blockedRCT.2(M=M, MDES=MDES, Ai=Ai, J=J, n.j=n.j,                    p=p, alpha=alpha, numCovar.1=numCovar.1, 
                 numCovar.2 = numCovar.2,R2.1=R2.1, R2.2=R2.2, ICC=ICC,                     mod.type = mod.type, 
                 sigma = sigma,
                 rho = 0.2, omega = omega, tnum = tnum, snum = snum, 
                 ncl = ncl, updateProgress = updateProgress)


#corr = 0.5
power.corr0.5 <- power.blockedRCT.2(M=M, MDES=MDES, Ai=Ai, J=J, n.j=n.j,                    p=p, alpha=alpha, numCovar.1=numCovar.1, 
                 numCovar.2 = numCovar.2,R2.1=R2.1, R2.2=R2.2, ICC=ICC,                     mod.type = mod.type, 
                 sigma = sigma,
                 rho = 0.5, omega = omega, tnum = tnum, snum = snum, 
                 ncl = ncl, updateProgress = updateProgress)
  

#corr = 0.8
power.corr0.8 <- power.blockedRCT.2(M=M, MDES=MDES, Ai=Ai, J=J, n.j=n.j,                    p=p, alpha=alpha, numCovar.1=numCovar.1, 
                 numCovar.2 = numCovar.2,R2.1=R2.1, R2.2=R2.2, ICC=ICC,                     mod.type = mod.type, 
                 sigma = sigma,
                 rho = 0.8, omega = omega, tnum = tnum, snum = snum, 
                 ncl = ncl, updateProgress = updateProgress)
  
#add data frames to a list to process it altogether
list_of_power <- list(power.corr0, power.corr0.2, power.corr0.5, power.corr0.8)

#add a correlation column to the data files
power.c <- Map(cbind, list_of_power, corr=corrlist)

#add mtps to cols
listmtps.p <- lapply(power.c, rowtocolumn)
power.b <- mapply(cbind, power.c, 'mtp' = listmtps.p, SIMPLIFY = F)

#bind list of tables into one dataframe
ourmethods <- ldply(power.b, data.frame)

```



# Create a table like the appendix table in the report : Verify power calculations against MC methods
```{r chunk3_verifyPower}
#manipulate data frames to make a combined table

#subset cols
ourmethods<- ourmethods[, c("indiv", "min1", "min2", "min3", "min4", "complete", "corr", "mtp")]
MCmethods<- MCmethods[, c("D1indiv", "min", "X1.3", "X1.2", "X2.3", "full", "corr", "mtp")]

#append a prefix
colnames(ourmethods) <- paste("method", colnames(ourmethods), sep = "_")
colnames(MCmethods) <- paste("sim", colnames(MCmethods), sep = "_")

#rename sim mtps for merge
MCmethods$newsim_mtp<- ifelse(MCmethods$sim_mtp == "Bonferroni", "BF",
                       ifelse(MCmethods$sim_mtp == "Holm", "HO", 
                       ifelse(MCmethods$sim_mtp == "WY", "WY-SD", as.character(MCmethods$sim_mtp))))        
                              
MCmethods$sim_mtp <- MCmethods$newsim_mtp

MCmethods$newsim_mtp <- NULL

#merge methods and sim tables
validtable <- merge(ourmethods, MCmethods, by.x = c("method_mtp", "method_corr"), by.y = c("sim_mtp", "sim_corr"), all = TRUE) 

#reorder columns and obs
##NOTE: We do not have WY-SS for simulations - we are currently keeping the matrices as they are and Kristin is going back to add WY-SS to the MC code

validtable$method_mtp <- ordered(validtable$method_mtp, c("rawp", "BF", "HO", "BH", "WY-SD", "WY-SS"))
validtable <- validtable[order(validtable$method_mtp),]

#rename cols
names(validtable)[names(validtable) == 'sim_X1.3'] <- 'sim_1/3'
names(validtable)[names(validtable) == 'sim_X1.2'] <- 'sim_1/2'
names(validtable)[names(validtable) == 'sim_X2.3'] <- 'sim_2/3'

#reorder cols
validtable <- validtable[, c("method_mtp", "method_corr", "method_indiv", "sim_D1indiv", "method_min1", "sim_min", "method_min2",
                             "sim_1/3", "method_min4", "sim_2/3", "method_complete", "sim_full")]


##create validation table our methods vs MC Sim

#adjust rownames to work with kable headers
rownames(validtable) <- c(1:24)

#subset the table to only the columns we care about
validtable.s <- validtable[, 2:12]

#convert columns from ordered factor to numeric (for rounding)
str(validtable)

as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}
validtable.s <- sapply(validtable.s, FUN = as.numeric.factor)

#round values in the table
validtable.s <- round(validtable.s, 2)

#display table
kable(validtable.s, caption = "MTP Used and Correlations") %>%
  kable_styling("striped") %>%
  add_header_above(c(" " = 1, "Individual" = 2, "1-minimal" = 2, "1/3-minimal" = 2, "2/3-minimal" = 2, "Complete" = 2)) %>%
  group_rows("No adjustment", 1, 4) %>%
  group_rows("Bonferroni", 5, 8) %>% 
  group_rows("Holm", 9, 12) %>%
  group_rows("Benjamini-Hochberg", 13, 16) %>%
  group_rows("Westfall-Young (step-down)", 17, 20) %>%
  group_rows("Westfall-Young (single-step)", 21, 24)


```

Are these topics still relevant?
-capture run times?

## Maybe different chunk for each design specification (e.g, constant, fixed, random effects)


```{r verifyPowerUp}
# for M=1, look up in Power-Up

  #app to generate power can be found here https://metinbulus.shinyapps.io/powerupr/
    #power from PowerUp! app: 0.1662404

#extract power estimate using PowerUp! package
powerUp<- power.bira2c1(es=.125, alpha=.05, two.tailed=TRUE, p=.50, g1=numCovar.1, r21=0, n=50, J=20)
powerUp.M1 <- powerUp$power


## Q FOR ZH/KP: What is the diff bt looking at indiv power and M=1?
#run power with M=1 from our package  - DOESNT RUN
#reset rho and sigma?
power.M1 <- power.blockedRCT.2(M=1, MDES=MDES, Ai=1, J=J, n.j=n.j, p=p,                alpha=alpha, numCovar.1=numCovar.1, numCovar.2 = numCovar.2,                R2.1=R2.1, R2.2=R2.2, ICC=ICC, mod.type = mod.type, 
               sigma = sigma,
               rho = 0, omega = omega, tnum = tnum, snum = snum, ncl = ncl,
               updateProgress = updateProgress)


####OLD - SEE Q from above:

#extract M=1 power from our methods
power.M1 <- validtable[which(validtable$method_mtp =="rawp" & validtable$method_corr == "0"), "method_indiv"]
power.M1 <- as.numeric(levels(power.M1))[power.M1]
  
# create table of results and check for if within TBD margin of error
powerUpvalidtable <- cbind(powerUp.M1, power.M1)
powerUpvalidtable

# create table of run times

```

# Verify MDES calculations and capture run times

```{r chunk4_verifyMDES}
#set margin of error 
me <- 0.01

####ASK ZH: Where is the rho (correlation) parameter for MDES calc? How do I switch out the correlation? Is it sigma?
  ##generate power for indiv, BH, corr = 0
  ## is numFalse the same as Ai?

## cor = 0
#indiv, BH
test.MDES <- MDES.blockedRCT.2(M = M, numFalse = M, Ai_mdes = M, J = J, n.j = n.j, power = power.corr0["BH", "indiv"], power.definition = "indiv", MTP = "BH", marginError = 0.05, p = p, alpha = 0.05, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2, R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = mod.type, sigma = sigma, omega = omega,tnum = tnum, snum = snum, ncl = ncl, updateProgress = updateProgress)

test.MDES[1] < (MDES + me) & test.MDES[1] > (MDES - me)


##ASK ZH: What are the categories for diff power.definition?
#min1, HO
test.MDES <- MDES.blockedRCT.2(M = M, numFalse = M, Ai_mdes = M, J = J, n.j = n.j, power = power.corr0["HO", "min1"], power.definition = "min1", MTP = "HO", marginError = 0.05, p = p, alpha = 0.05, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2, R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = mod.type, omega = omega,tnum = tnum, snum = snum, ncl = ncl, updateProgress = updateProgress)

test.MDES[1] < (MDES + me) & test.MDES[1] > (MDES - me)

```

# Verify sample size calculations and capture run times

```{r chunk4_verifySampleSize}

# Specify power estimates that match those obtained in chunk3_verifyPower (grab from final table/matrix) and corresponding MDES - and check that returned sample size is correct

# repeat for number of blocks, number within blocks, etc. 

```

# ?? Verify error messages


```{r chunk4_verifyErrorsWarnings}

# Pass in anticipated mistakes and show return of error messages/warnings?

```



