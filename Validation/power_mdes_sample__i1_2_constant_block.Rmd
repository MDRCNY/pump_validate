---
title: "Validate_power_mdes_sample_blocked_i1_2c"
author: "Kristin Porter & Zarni Htet"
output:
  html_document:
    code_folding: hide
    df_print: paged
    fig_caption: yes
    fig_height: 8
    fig_width: 10
    highlight: monochrome
    theme: spacelab
    toc: yes
    toc_depth: 5
    toc_float: yes
  github_document:
    df_print: paged
    fig_caption: yes
    fig_height: 8
    fig_width: 10
    toc: yes
---

### Libraries and Source Files

```{r libraries, warnings = FALSE, message = FALSE}
library(RcppEigen) # Linear algebra calculations
library(snow)      # Parallelization and use of multiple clusters 
library(lme4)      # Linear mixed effect models
library(PowerUpR)  # Comparison with another package that has some limitations
library(multtest)  # Multiple Testing Procedures package
library(tictoc)    # For timing of the scripts
library(here)      # For relative path sourcing
library(pum)       # For Power Under Multiplicity Package
library(dplyr)     # For combining different dataframes
```
  
```{r sourcefiles, warnings = FALSE, message = FALSE}
source(here::here("Validation/Simulations", "adjust.WY.R")) # MTP Westfall-Young
source(here::here("Validation/Simulations", "gen_data_dist_2_levels.R")) # data generating functions for 2 level block and cluster
source(here::here("Validation/Simulations", "power_mcs_2_levels.R")) # Estimate power for each of the designs by running data generating function S sample times and fitting models to estimate power.
source(here::here("Validation/Simulations", "validate_power_mdes_sample_blocked_i1_2c.R")) # 
```

### 2 Level Constant Effect Comparison for Raw Power with PowerUp

* ICC needs to be zero for constant and fixed effets


```{r constant_effect_power_up_comparison}
rho <- c(0.5)
ncl <-2 
procs <- c("Bonferroni", "BH", "Holm") 
design <- c("Blocked_i1_2c")
M <- 3 
MDES <- rep(0.125, M) 
S = 2000 # (Number of samples for Monte Carlo Simulation)
B = 2 # (Number of samples for WestFall-Young. The equivalent is snum in our new method)
tnum = 10000 #The number of test statistics (samples) for all procedures other than Westfall-Young. The default is set at 10000
J = 20 
n.j = 100 
p.j <- 0.5 
p.j.range <- rep(0.5,J) 
theta <- matrix(0,M,M) 
diag(theta) <- 0 
omega <- rep(0,M) 
Gamma.00 <- rep(0,M) 
sig.sq <- rep(1,M)
alpha <- 0.05 
ICC <- rep(0, M) 
R2.2 <- rep(0,M)  
R2.1 <- rep(0, M) 
maxT <- FALSE 
check <- FALSE #usually for checking the code. Do not need to  
storage_path <- "./Validation/data"
validation_name <- "Blocked_i1_2c"
runSim <- TRUE
runPump <- TRUE
```

### Firing Up & Storing Results from Monte Carlo Simulation Runs

```{r}
tic("validating_two_level_block_constant_effect")
blocked_i1_2c_compare_results <- validate_power_blocked_i1_2cfr(rho = rho, ncl = ncl, procs = procs, design = design, M = M, MDES = MDES,
                                                                   p.j = p.j,p.j.range = p.j.range, S = S, B = B, tnum = tnum, J = J, 
                                                                   n.j = n.j, theta = theta, omega = omega, Gamma.00 = Gamma.00, sig.sq = sig.sq,
                                                                   alpha = alpha, ICC = ICC, R2.2 = R2.2, R2.1 = R2.1, maxT = maxT, rho.0_lev1 = rho.0_lev1,
                                                                   rho.0_lev2 = rho.0_lev2, rho.1_lev2 = rho.1_lev2, check = check, storage_path = storage_path, validation_name = validation_name, runSim = runSim, runPump = runPump)
toc(log = TRUE)
print(blocked_i1_2c_compare_results)
#View(blocked_i1_2c_compare_results)
```


## MDES function validation

We are testing the MDES function by putting in the parameters of the simulated power function and checking if we receive an MDES estimation within range.

```{r}
# Loading our pum library
library(pum)
```

* M = 3
* MDES = 0.125
* numFalse = 6
* J = 20
* n.j = 100
* R2.1 = 0.5
* p = 0.5
* alpha = 0.05
* numCovar.1 = 5
* numCovar.2 = NULL
* rho = 0.5
* tnum = 10000
* snum = 2000
* updateProgress = NULL

```{r}
tic()
power_M3_BF_MDES0125 <- pum::power_blocked_i1_2c(M = 3, MTP = "Bonferroni", MDES = 0.125, numFalse = 3, J = 20, n.j = 50, 
                         R2.1 = 0.5, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                         rho = 0.5,tnum = 10000, snum =2000, ncl = 8)
toc()
print(power_M3_BF_MDES0125)
```

```{r}
tic()
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = 3, MTP = "BH", MDES = 0.125, numFalse = 3, J = 20, n.j = 50, 
                         R2.1 = 0.5, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                         rho = 0.5,tnum = 10000, snum =2000, ncl = 8)
toc()
print(power_M3_BH_MDES0125)
```

```{r}
tic()
power_M3_HO_MDES0125 <- pum::power_blocked_i1_2c(M = 3, MTP = "HO", MDES = 0.125, numFalse = 3, J = 20, n.j = 50, 
                         R2.1 = 0.5, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                         rho = 0.5,tnum = 10000, snum =2000, ncl = 8)
toc()
print(power_M3_HO_MDES0125)
```

### MDES for Individual Power is working

```{r}
tic()
mdes_0125_bonf_indiv <- pum::mdes_blocked_i1_2c(M = 3, numFalse = 3,J = 20, n.j = 50, power = power_M3_BF_MDES0125["BF", "indiv"],
                                          power.definition = "indiv", MTP = "BF", marginError = 0.05,
                                          p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                                          R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", 
                                          rho = 0.5, omega = NULL,tnum = 10000, snum = 2000, ncl = 8)
toc()
print(mdes_0125_bonf_indiv)
```

```{r}
tic()
mdes_0125_bh_indiv <- pum::mdes_blocked_i1_2c(M = 3, numFalse = 3,J = 20, n.j = 50, power = power_M3_BH_MDES0125["BH", "indiv"],
                                          power.definition = "indiv", MTP = "BH", marginError = 0.05,
                                          p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                                          R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", 
                                          rho = 0.5, omega = NULL,tnum = 1000, snum = 500, ncl = 8)
toc()
print(mdes_0125_bh_indiv)
```

```{r}
tic()
mdes_0125_holms_indiv1 <- pum::mdes_blocked_i1_2c(M = 3, numFalse = 3,J = 20, n.j = 50, power = power_M3_HO_MDES0125["HO", "indiv1"],
                                          power.definition = "indiv1", MTP = "HO", marginError = 0.05,
                                          p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                                          R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", 
                                          rho = 0.5, omega = NULL,tnum = 10000, snum = 2000, ncl = 8)
toc()
print(mdes_0125_holms_indiv1)
```


### Non-Individual Power for MDES is NOT working

```{r}
tic()
mdes_0125_holms_min1 <- pum::mdes_blocked_i1_2c(M = 3, numFalse = 3,J = 20, n.j = 50, power = power_M3_HO_MDES0125["HO","min1"],
                                          power.definition = "min1", MTP = "HO", marginError = 0.05,
                                          p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                                          R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", 
                                          rho = 0.5, omega = NULL,tnum = 10000, snum = 1000, ncl = 8)
toc()
print(mdes_0125_holms_min1)
```

```{r}
tic()
mdes_0125_bh_min1 <- pum::mdes_blocked_i1_2c(M = 3, numFalse = 3,J = 20, n.j = 50, power = power_M3_BH_MDES0125["BH", "min1"],
                                          power.definition = "min1", MTP = "BH", marginError = 0.05,
                                          p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                                          R2.1 = 0.5, R2.2 = 0, ICC = 0, mod.type = "constant", 
                                          rho = 0.5, omega = NULL,tnum = 10000, snum = 1000, ncl = 8)
toc()
print(mdes_0125_bh_min1)
```


## Sample Function Validation

We are testing the MDES function by putting in the parameters of the simulated power function and checking if we receive an MDES estimation within range.

```{r}
# Loading our pum library
library(pum)
```

```{r}
sample_BF_J_20 <- sample_blocked_i1_2c(M = 6, numFalse = 6, typesample = "J", J = NULL, n.j = 100, 
                                    J0 = 10, n.j0 = NULL, MDES = 0.125, power = 0.9064167 ,
                                    power.definition = "indiv", MTP = "BF", marginError = 0.05,
                                    p = 0.5,alpha = 0.05,numCovar.1 = 5,numCovar.2 = 1,
                                    R2.1 = 0.5,tnum = 10000, snum = 2000, ncl = 8)
print(sample_BF_J_20)
```

```{r}
tic()
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = 3, MTP = "BH", MDES = 0.125, numFalse = 3, J = 20, n.j = 50, 
                         R2.1 = 0.5, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                         rho = 0.5,tnum = 10000, snum =2000, ncl = 8)
toc()
print(power_M3_BH_MDES0125)
```

```{r}
tic()
power_M3_HO_MDES0125 <- pum::power_blocked_i1_2c(M = 3, MTP = "HO", MDES = 0.125, numFalse = 3, J = 20, n.j = 50, 
                         R2.1 = 0.5, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                         rho = 0.5,tnum = 10000, snum =2000, ncl = 8)
toc()
print(power_M3_HO_MDES0125)
```

```{r}
tic()
power_M3_BH_MDES0125 <- pum::power_blocked_i1_2c(M = 3, MTP = "BH", MDES = 0.125, numFalse = 3, J = 20, n.j = 50, 
                         R2.1 = 0.5, p = 0.5, alpha = 0.05, numCovar.1 = 5, numCovar.2 = NULL,
                         rho = 0.5,tnum = 10000, snum =2000, ncl = 8)
toc()
print(power_M3_BH_MDES0125)
```

```{r}
sample_BH_indiv_nj_50 <- sample_blocked_i1_2c(M = 3, numFalse = 3, MTP = "BH", typesample = "n.j", J = 20, n.j = NULL, 
                                    J0 = NULL, n.j0 = 50, MDES = 0.125, power = power_M3_BH_MDES0125["BH", "indiv"] ,
                                    power.definition = "indiv", marginError = 0.05,
                                    p = 0.5,alpha = 0.05,numCovar.1 = 5,numCovar.2 = 1,
                                    R2.1 = 0.5,tnum = 10000, snum = 2000, ncl = 8)
print(sample_BH_indiv_nj_50)
```


```{r}
sample_BH_min1_J_20 <- sample_blocked_i1_2c(M = 3, numFalse = 3, typesample = "J", J = NULL, n.j = 50, 
                                    J0 = 10, n.j0 = NULL, MDES = 0.125, power = power_M3_BH_MDES0125["BH", "min1"] ,
                                    power.definition = "min1", MTP = "BH", marginError = 0.05,
                                    p = 0.5,alpha = 0.05,numCovar.1 = 5,numCovar.2 = 1,
                                    R2.1 = 0.5,tnum = 10000, snum = 2000, ncl = 8)
print(sample_BH_min1_J_20)
```

```{r}
sample_HO_J_20_indiv <- sample_blocked_i1_2c(M = 3, numFalse = 3, typesample = "J", J = NULL, n.j = 50, 
                                    J0 = 10, n.j0 = NULL, MDES = 0.125, power = power_M3_HO_MDES0125["HO", "indiv"] ,
                                    power.definition = "indiv", MTP = "HO", marginError = 0.05,
                                    p = 0.5,alpha = 0.05,numCovar.1 = 5,numCovar.2 = 1,
                                    R2.1 = 0.5,tnum = 10000, snum = 2000, ncl = 8)
print(sample_HO_J_20_indiv)
```

```{r}
sample_HO_nj_50_indiv <- sample_blocked_i1_2c(M = 3, numFalse = 3, typesample = "n.j", J = 20, n.j = NULL, 
                                    J0 = NULL, n.j0 = 10, MDES = 0.125, power = power_M3_HO_MDES0125["HO", "indiv"] ,
                                    power.definition = "indiv", MTP = "HO", marginError = 0.05,
                                    p = 0.5,alpha = 0.05,numCovar.1 = 5,numCovar.2 = 1,
                                    R2.1 = 0.5,tnum = 10000, snum = 2000, ncl = 8)
print(sample_HO_nj_50_indiv)
```



