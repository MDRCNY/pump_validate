---
title: "Validate_power_mdes_sample_blocked_i1_2c"
author: "Kristin Porter & Zarni Htet"
output:
  html_document:
    code_folding: hide
    df_print: paged
    fig_caption: yes
    fig_height: 8
    fig_width: 10
    highlight: monochrome
    theme: spacelab
    toc: yes
    toc_depth: 5
    toc_float: yes
  github_document:
    df_print: paged
    fig_caption: yes
    fig_height: 8
    fig_width: 10
    toc: yes
---
# Purpose

This document lays out validation steps & results for estimating statistical power, minimum detectable effect size (MDES) and sample size for 2-Level Block RCT with constant effects experimental design. We compare results of the derived methods against Monte Carlo Simulations & the PowerUp R package on power, mdes and sample size. The methods are derived by Kristin Porter as outlined in the paper/s here (Add reference section). 

### Set Up

In this section, we set up the required R packages and source files to run the rest of the Validation document.

```{r knit.options}
# by default, all code chunks will cache their results
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, message = FALSE)
```

```{r libraries}
library(dplyr)     # For combining different dataframes
library(here)      # For relative path sourcing
library(lme4)      # Linear mixed effect models
library(MASS)
library(multtest)  # Multiple Testing Procedures package
library(nlme)
library(pander)    # For good table format
library(PowerUpR)  # Comparison with another package that has some limitations
library(pum)       # For Power Under Multiplicity Package
library(RcppEigen) # Linear algebra calculations
library(snow)      # Parallelization and use of multiple clusters
library(tictoc)    # For timing of the scripts
```

```{r scriptFiles}
 # MTP Westfall-Young
source(here::here("Validation/Simulations", "adjust_WY.R"))
# data generating function
source(here::here("Validation/Simulations", "gen_data.R"))
# Estimate power for each of the designs by running data generating function S sample times and fitting models to estimate power.
source(here::here("Validation/Simulations", "estimate_power_with_simulation.R"))
# Wrapping and creating 
source(here::here("Validation/Simulations", "validate_power_mdes_sample_blocked_i1_2c.R"))
# For coloring texts and other purposes
source(here::here("Validation/Simulations", "misc.R")) 
```

# Power Validation

In this section, we validate power results for different definitions of power, __minimum__, __individual__ and __complete__ for three multiple adjustment multiple methods, __Bonferroni__, __Benjamini Hocheberg__ and __Holm__.

Each subsection of the power validation below is a variation of correlation between outcomes, __rho__ & the ratio of __false nulls__ in M outcomes. For more details on input parameters, please refer to the paper or the Appendix section at the bottom of this markdown.

If you are previewing this in html, please click on the code section to review more detailed parameters.


This section sets up the simulation-level parameters, such as how many monte carlo samples to draw.

```{r}
# list of simulation parameters
sim.params.list = list(
    S = 10           # Number of samples for Monte Carlo Simulation
  , B = 2            # Number of samples for WestFall-Young. The equivalent is snum in our new method.
  , maxT = FALSE     # ?
  , alpha = 0.05     # significance level
  , p.j = 0.5        # binomial assignment probability
  , tnum = 10000     # Number of test statistics (samples) for all procedures other than Westfall-Young
  , ncl = 2          # Number of computer clusters (max on RStudio Server is 16)
  , procs = c("Bonferroni", "BH", "Holm") # multiple testing procedures to compute power for 
  , runSim = TRUE    # if TRUE, we will re-run the simulation. if FALSE, we will pull previous run result.
  , runPump = TRUE   # if TRUE, we will run method from our package. if FALSE, we will pull previous run result.
  , check = FALSE    # run checks such as printing out quantities
)
```

This section sets up the model parameters, such as the number of outcomes and correlation structures.

```{r}
# option 1: input higher-level params, and allow for simple defaults
# assumes equal sized schools that are evenly split between districts
# assumes same correlation structure across all outcomes, covariates, random effects, etc.
simple.user.params.list <- list(
  M = 3                     # Number of outcomes
  , J = 20                  # Number of schools
  , K = 2                   # Number of districts                  
  , n.j = 100               # Number of students per school
  , rho.default = 0.5       # Default correlation
)
assignment.vecs <- gen_simple_assignments(
  J = simple.user.params.list[['J']],
  K = simple.user.params.list[['K']],
  n.j = simple.user.params.list[['n.j']]
)
default.rho.matrix <- gen_corr_matrix(
  M = simple.user.params.list[['M']],
  rho.scalar = simple.user.params.list[['rho.default']]
)

M <- simple.user.params.list[['M']]
rho.default <- simple.user.params.list[['rho.default']]
S.j <- assignment.vecs[['S.j']]
S.k = assignment.vecs[['S.k']]  
rho.D <- rho.w <- rho.z <- default.rho.matrix
rho.X <- rho.u <- rho.v <- default.rho.matrix
rho.C <- rho.r <- default.rho.matrix
theta.wz <- theta.uv <- matrix(0, M, simple.user.params.list[['M']])

# option 2: set these parameters yourself with more complicated parameters
# rho.default <- NULL
## school and district assignments
# S.j <-
# S.k <-
# 
# ## covariates
# rho.D <- 
# rho.X <- 
# rho.C <- 
# 
# ### random effects and impacts
# rho.w <- 
# rho.z <- 
# rho.u <-
# rho.v <- 
# rho.r <- 
# theta.wz <-
# theta.uv <-
```

```{r}
user.params.list <- list(
  M = M
  , J = max(S.j)                          # number of schools
  , K = max(S.k)                          # number of districts
  , N = length(S.j)                       # number of individuals
  , n.j = length(S.j)/max(S.j)            # number of individuals per school
  , rho.default = rho.default             # if supplied, default rho value
  , S.j = S.j                             # N-length vector of indiv school assignments i.e. (1,1,2,2,3,3)
  , S.k = S.k                             # N-length vector of indiv district assignments i.e. (1,1,1,2,2,2)
  ################################################## level 3
  , Xi0 = 0                               # scalar grand mean outcome under no treatment
  , MDES = rep(0.125, M)                  # minimum detectable effect size                              
  , R2.3 = rep(0, M)                      # percent of district variation explained by district covariates
  , rho.D = rho.D                         # MxM correlation matrix of district covariates
  , ICC.3 = 0.3                           # district intraclass correlation	
  , omega.3 = 0.5                         # ratio of district effect size variability to random effects variability
  , rho.w = rho.w                         # MxM matrix of correlations for district random effects
  , rho.z = rho.z                         # MxM matrix of correlations for district impacts
  , theta.wz = theta.wz                   # MxM matrix of correlations between district random effects and impacts
  ################################################## level 2
  , R2.2 = rep(0, M)                      # percent of school variation explained by school covariates
  , rho.X = rho.X                         # MxM correlation matrix of school covariates
  , ICC.2 = 0.3                           # school intraclass correlation	
  , omega.2 = 0.5                         # ratio of school effect size variability to random effects variability
  , rho.u = rho.u                         # MxM matrix of correlations for school random effects
  , rho.v = rho.v                         # MxM matrix of correlations for school impacts
  , theta.uv = theta.uv                   # MxM matrix of correlations between school random effects and impacts
  ################################################## level 1
  , R2.1 = rep(0, M)                      # percent of indiv variation explained by indiv covariates
  , rho.C = rho.C                         # MxM correlation matrix of individual covariates
  , rho.r = rho.r                         # MxM matrix of correlations for individual residuals 
)
```


### n.j = 100, M = 3, numFalse = M, J = 20, rho = (0.5, 0.5, 0.5), MDES = (0.125, 0.125, 0.125), R2.2 = (0,0,0)
# banana question: what is numfalse?

`r colorize("Individual Statistical power is estimated to be around 0.8. Please check the table below for estimations of other definitions of statistical power. Across all power definitions, estimation results across the __PUMP__ package, __Monte Carlo Simulation__ results and __PowerUp__ package are about the same as detailed below.", "green")`

`r colorize("We will be adding Westfall-Young step down adjustment later on.", "red")`

```{r rho0.5numFalseMRun01}
blocked_i1_2c_compare_results <- validate_power_blocked_i1_2cfr(
  user.params.list = user.params.list, sim.params.list = sim.params.list, 
  design = "Blocked_i1_2c"
)
pander::pandoc.table(
  blocked_i1_2c_compare_results,
  paste0("PowerSimulation_", "rho_", simple.user.params.list[['rho.default']],"_falseNull_", user.params.list[['M']]),
  style = "grid", split.tables = 100
)
```
