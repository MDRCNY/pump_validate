---
title: "Verification for 2-Level Blocked RCT with Constant Effects"
author: "Deni Chen"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: github_document:
    toc: true
    toc_float: true
    number_sections: true
    #theme: cerulean
---

# Set up

```{r}
#this is validation template was created before we migrated power calculations to the pum package
library(yaml)
library(knitr)
library(kableExtra)
library(PowerUpR)
library(pum)
library(plyr)
library(rio)
#source(file = "../Power-Under-Multiplicity/blockrct2_power.R")

#read in configs file
configs <- yaml.load_file("configs.yaml")

#set directory for reading in files
fdir <- configs$fdir

#set margin of error
me <- 0.01  
```


# Load power calculation matrices from the simulations

```{r}
simpwr0 <- "Blocked_i1_2cM6n.j100J20ICC0MDES0.125rho0_S2000B10000_R2.10_R2.20_simpwr.Rda"
simpwr.2 <- "Blocked_i1_2cM6n.j100J20ICC0MDES0.125rho0.2_S2000B10000_R2.10_R2.20_simpwr.Rda"
simpwr.5 <- "Blocked_i1_2cM6n.j100J20ICC0MDES0.125rho0.5_S2000B10000_R2.10_R2.20_simpwr.Rda"
simpwr.8 <- "Blocked_i1_2cM6n.j100J20ICC0MDES0.125rho0.8_S2000B10000_R2.10_R2.20_simpwr.Rda"

simpwr.cor0 = local(get(load(paste0(fdir, simpwr0))))
simpwr.cor.2 = local(get(load(paste0(fdir, simpwr.2))))
simpwr.cor.5 = local(get(load(paste0(fdir, simpwr.5))))
simpwr.cor.8 = local(get(load(paste0(fdir, simpwr.8))))

#add data frames to a list to process it altogether
list_of_simpwr <- list(simpwr.cor0, simpwr.cor.2, simpwr.cor.5, simpwr.cor.8)

#add a correlation column to the data files
corrlist <- c(0, .2,.5,.8)
mtplist <- c("rawp", "BF", "BH", "HO", "WY-SD")

simpwr.c <- Map(cbind, list_of_simpwr, corr=corrlist)

#set up function to get mtps into col
rowtocolumn <- function(df){
  df$mtp <- row.names(df)
  return(df$mtp)
}

#add mtps to cols
listmtps <- lapply(simpwr.c, rowtocolumn)
simpwr.b <- mapply(cbind, simpwr.c, 'mtp' = listmtps, SIMPLIFY = F)

#bind sim tables
MCmethods <- ldply(simpwr.b, data.frame)

```


# Pull in power calculations (via the pum package)
```{r}
#set parameters for function
M <- 6
MDES <- 0.125
Ai <- 6
J <- 20
n.j <- 100
p <- 0.5
alpha <- 0.05
numCovar.1 <- 0
numCovar.2 <- 0
R2.1 <- 0 
R2.2 <- 0 
ICC <- 0 
mod.type <- 'c'
omega <- 0
tnum <- 10000
#snum <-  500
snum <- 2000
ncl <- 2
updateProgress <- NULL
sigma <- 0 ## NOTE: sigma is a matrix of row currently (line 232 on pump repo)


#generate power calculations for different correlations
#gen.powerobj <- function(corr){

#power.blockedRCT.2(M=M, MDES=MDES, Ai=Ai, J=J, n.j=n.j, p=p,                alpha=alpha, numCovar.1=numCovar.1, numCovar.2 = numCovar.2, R2.1=R2.1,     R2.2=R2.2, ICC=ICC, mod.type = mod.type, 
#               sigma = sigma,
#               rho = corr, omega = omega, tnum = tnum, snum = snum, ncl = ncl,
#               updateProgress = updateProgress)
#}

#power.corr0 <- gen.powerobj(0)
#power.corr0.2 <- gen.powerobj(0.2)
#power.corr0.5 <- gen.powerobj(0.5)
#power.corr0.8 <- gen.powerobj(0.8)

#save these files so we dont have to rerun (power matrices take 10 min to run 4)
#export(power.corr0, "power_corr0.rds")
#export(power.corr0.2, "power_corr02.rds")
#export(power.corr0.5, "power_corr05.rds")
#export(power.corr0.8, "power_corr08.rds")

#import files
power.corr0  <- import("I:\\Multiplicity\\git\\power_corr0.rds")
power.corr0.2<- import("I:\\Multiplicity\\git\\power_corr02.rds")
power.corr0.5<- import("I:\\Multiplicity\\git\\power_corr05.rds")
power.corr0.8<- import("I:\\Multiplicity\\git\\power_corr08.rds")


#can further functionalize - wrap function call in loop
#objn <- c("power.corr0", "power.corr0.2", "power.corr0.5", "power.corr0.8")
          
#for c in corrlist {
#  power.corr0 <- gen.powerobj(c)
  
#}    



  
#add data frames to a list to process it altogether
list_of_power <- list(power.corr0, power.corr0.2, power.corr0.5, power.corr0.8)

#add a correlation column to the data files
power.c <- Map(cbind, list_of_power, corr=corrlist)

#add mtps to cols
listmtps.p <- lapply(power.c, rowtocolumn)
power.b <- mapply(cbind, power.c, 'mtp' = listmtps.p, SIMPLIFY = F)

#bind list of tables into one dataframe
ourmethods <- ldply(power.b, data.frame)

```



# Create a table like the appendix table in the report : Verify power calculations against MC methods
```{r chunk3_verifyPower}
#manipulate data frames to make a combined table

#subset cols
ourmethods<- ourmethods[, c("indiv", "min1", "min2", "min3", "min4", "complete", "corr", "mtp")]
MCmethods<- MCmethods[, c("D1indiv", "min", "X1.3", "X1.2", "X2.3", "full", "corr", "mtp")]

#append a prefix
colnames(ourmethods) <- paste("method", colnames(ourmethods), sep = "_")
colnames(MCmethods) <- paste("sim", colnames(MCmethods), sep = "_")

#rename sim mtps for merge
MCmethods$newsim_mtp<- ifelse(MCmethods$sim_mtp == "Bonferroni", "BF",
                       ifelse(MCmethods$sim_mtp == "Holm", "HO", 
                       ifelse(MCmethods$sim_mtp == "WY", "WY-SD", as.character(MCmethods$sim_mtp))))        
                              
MCmethods$sim_mtp <- MCmethods$newsim_mtp

MCmethods$newsim_mtp <- NULL

#merge methods and sim tables
validtable <- merge(ourmethods, MCmethods, by.x = c("method_mtp", "method_corr"), by.y = c("sim_mtp", "sim_corr"), all = TRUE) 

#reorder columns and obs
##NOTE: We do not have WY-SS for simulations - we are currently keeping the matrices as they are and Kristin is going back to add WY-SS to the MC code

validtable$method_mtp <- ordered(validtable$method_mtp, c("rawp", "BF", "HO", "BH", "WY-SD", "WY-SS"))
validtable <- validtable[order(validtable$method_mtp),]

#rename cols
names(validtable)[names(validtable) == 'sim_X1.3'] <- 'sim_1/3'
names(validtable)[names(validtable) == 'sim_X1.2'] <- 'sim_1/2'
names(validtable)[names(validtable) == 'sim_X2.3'] <- 'sim_2/3'

#reorder cols
validtable <- validtable[, c("method_mtp", "method_corr", "method_indiv", "sim_D1indiv", "method_min1", "sim_min", "method_min2",
                             "sim_1/3", "method_min4", "sim_2/3", "method_complete", "sim_full")]


##create validation table our methods vs MC Sim

#adjust rownames to work with kable headers
rownames(validtable) <- c(1:24)

#subset the table to only the columns we care about
validtable.s <- validtable[, 2:12]

#convert columns to numeric (for rounding)
validtable.s <- apply(validtable.s, 2, as.numeric)

#round values in the table
validtable.s <- round(validtable.s, 3)

#display table
kable(validtable.s, caption = "MTP Used and Correlations") %>%
  kable_styling("striped") %>%
  add_header_above(c(" " = 1, "Individual" = 2, "1-minimal" = 2, "1/3-minimal" = 2, "2/3-minimal" = 2, "Complete" = 2)) %>%
  group_rows("No adjustment", 1, 4) %>%
  group_rows("Bonferroni", 5, 8) %>% 
  group_rows("Holm", 9, 12) %>%
  group_rows("Benjamini-Hochberg", 13, 16) %>%
  group_rows("Westfall-Young (step-down)", 17, 20) %>%
  group_rows("Westfall-Young (single-step)", 21, 24)


```

Are these topics still relevant?
-capture run times?

## Maybe different chunk for each design specification (e.g, constant, fixed, random effects)

#Verify M=1 against PowerUp!
```{r verifyPowerUp}
# for M=1, look up in Power-Up

#extract power estimate using PowerUp! package
powerUp<- power.bira2c1(es=.125, alpha=.05, two.tailed=TRUE, p=.50, g1=numCovar.1, r21=0, n=100, J=20)
powerUp.M1 <- powerUp$power

#extract M=1 power from our methods
power.M1 <- validtable[which(validtable$method_mtp =="rawp" & validtable$method_corr == "0"), "method_indiv"]
#power.M1 <- as.numeric(levels(power.M1))[power.M1]
  
#check if our power results are within the margin of error of the powerUp results
powerUp$power < (power.M1 + me) & powerUp$power > (power.M1 - me)

#look at the result and check for if within margin of error
powerUpvalidtable <- cbind(powerUp.M1, power.M1)
powerUpvalidtable


#run power with M=1 from our package  - DOESNT RUN
#power.M1 <- power.blockedRCT.2(M=1, MDES=MDES, Ai=1, J=J, n.j=n.j, p=p,                alpha=alpha, numCovar.1=numCovar.1, numCovar.2 = numCovar.2,                R2.1=R2.1, R2.2=R2.2, ICC=ICC, mod.type = mod.type, 
#               sigma = sigma,
 #              rho = 0, omega = omega, tnum = tnum, snum = snum, ncl = ncl,
 #              updateProgress = updateProgress)


```

# Verify MDES calculations and capture run times

```{r chunk4_verifyMDES}
#set up a function to automate some of this- under construction
MDEStest <- function(powerds, mtpn, defn, corr){
  
  test.MDES <- MDES.blockedRCT.2(M = M, numFalse = M, Ai_mdes = M, J = J, n.j = n.j, power = powerds[mtpn, defn], power.definition = defn, MTP = mtpn, marginError = 0.05, p = p, alpha = 0.05, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2, R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = mod.type, sigma = sigma, rho=corr, omega = omega,tnum = tnum, snum = snum, ncl = ncl, updateProgress = updateProgress)
 
 print(test.MDES)
  
 bool <- test.MDES[1] < (MDES + me) & test.MDES[1] > (MDES - me)
 return(list(bool, test.MDES))
}

MDEStest(power.corr0, "BH", "indiv", 0) #TRUE
MDEStest(power.corr0, "HO", "indiv", 0) #FALSE
MDEStest(power.corr0, "BF", "indiv", 0) #Verification template format is off. 


MDEStest(power.corr0, "BH", "min1", 0) #FALSE
MDEStest(power.corr0, "BF", "min1", 0)
MDEStest(power.corr0, "HO", "min1", 0)

MDEStest(power.corr0, "BH", "min4", 0)
MDEStest(power.corr0, "BF", "min4", 0)






#for Domino, calculate MDES for all power calc and check if it is within range
#holder <- NULL
#MDEStest <- function(powerds, corr){
       
#      res <- list()
#      res$no_error <- TRUE
#      res$error <- list()
      
#      idx <- 1
#      for(i in rownames(powerds)){
#        for(j in colnames(powerds)){
#          test.MDES <- MDES.blockedRCT.2(M = M, numFalse = M, Ai_mdes = M, J = J, n.j = n.j, power = powerds[i, j], power.definition = j, MTP = i, marginError = 0.05, p = p, alpha = 0.05, numCovar.1 = numCovar.1, numCovar.2 = numCovar.2, R2.1 = R2.1, R2.2 = R2.2, ICC = ICC, mod.type = mod.type, sigma = sigma, rho=corr, omega = omega,tnum = tnum, snum = snum, ncl = ncl, updateProgress = updateProgress)
#          if((test.MDES[1] < (MDES + me) & test.MDES[1] > (MDES - me) ) == FALSE){
            
#            res$no_error <- FALSE
#            error_index <- paste(i, ",", j)
#            res$error[[idx]] <- error_index
            #print(j)
#            print(paste("lower bound: ", MDES - me, "  upper bound: ", MDES + me, "  true value: ", powerds[i,j], "  indices: ", error_index, sep = ""))
           #print((MDES - me))
           # print(power.corr0[i,j])
           # print(MDES + me)
#            idx <- idx + 1
#          }
#        }
#      }
      
#      return(res)
#} 

#testmd <- MDEStest(power.corr0, 0)







```

# Verify sample size calculations and capture run times

```{r chunk4_verifySampleSize}
SStest <- function(powerds, mtpn, defn){
  
  test.SS <- SS.blockedRCT.2(M, numFalse = M, J, n.j=NULL, J0=J0, n.j0=n.j0, MDES = MDES, power=powerds[mtpn,defn], power.definition = defn, MTP = mtpn, marginError = 0.005,p, alpha, numCovar.1=0, numCovar.2=0, R2.1=r2, R2.2=0, ICC=0, mod.type="constant", sigma=sigma, omega=NULL,  tnum = 10000, snum=2, ncl=4)
  
  print(test.SS)

}

SStest(power.corr0, "BH", "indiv")



# Specify power estimates that match those obtained in chunk3_verifyPower (grab from final table/matrix) and corresponding MDES - and check that returned sample size is correct

# repeat for number of blocks, number within blocks, etc. 

```

# ?? Verify error messages


```{r chunk4_verifyErrorsWarnings}

# Pass in anticipated mistakes and show return of error messages/warnings?

```



