---
title: "Validate Power: blocked_i1_2c"
author: "Kristin Porter, Zarni Htet, Kristen Hunter"
output:
  html_document:
    code_folding: hide
    df_print: paged
    fig_caption: yes
    fig_height: 8
    fig_width: 10
    highlight: monochrome
    theme: spacelab
    toc: yes
    toc_depth: 5
    toc_float: yes
  github_document:
    df_print: paged
    fig_caption: yes
    fig_height: 8
    fig_width: 10
    toc: yes
---
# Purpose

This document lays out results for estimating statistical power and minimum detectable effect size (MDES) for:
Blocked RCT, with 2 levels, constant treatment effects, and randomization done at level 1 (individual level).

We compare results of the derived methods against Monte Carlo Simulations & the PowerUp R package on power. The methods are derived by Kristin Porter as outlined in the paper/s here (Add reference section).

TODO: Add sample size, Westfall-Young

```{r knit.options, echo = FALSE}
# by default, all code chunks will cache their results
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, message = FALSE, echo = FALSE)
```

```{r libraries}
library(here)
library(MASS)
library(nlme)
library(pander)    # For good table format
```

```{r scriptFiles}
 # MTP Westfall-Young
source(here::here("Validation/Simulations", "adjust_WY.R"))
# data generating function
source(here::here("Validation/Simulations", "gen_data.R"))
# Estimate power for each of the designs by running data generating function S sample times and fitting models to estimate power.
source(here::here("Validation/Simulations", "estimate_power_with_simulation.R"))
# Wrapping and creating 
source(here::here("Validation/Simulations", "validate_power.R"))
# For coloring texts and other purposes
source(here::here("Validation/Simulations", "misc.R")) 
```

# Power Validation

In this section, we validate power results for different definitions of power, __minimum__, __individual__ and __complete__ for three multiple adjustment multiple methods: __Bonferroni__, __Benjamini Hocheberg__ and __Holm__.

Each subsection of the power validation below is a variation of __rho__, the correlation between outcomes, the __number of individuals per school__, and the number of __true positives__ in M outcomes. For more details on input parameters, please refer to the paper or the Appendix section at the bottom of this markdown.

If you are previewing this in html, please click on the code section to review more detailed parameters.

This section sets up the simulation-level parameters, such as how many monte carlo samples to draw.

```{r simulation.parameters.setup, echo = TRUE}
sim.params.list = list(
    S = 2000         # Number of samples for Monte Carlo Simulation
  , B = 2            # Number of samples for WestFall-Young. The equivalent is snum in our new method.
  , maxT = FALSE     # In WY procedure, whether to adjust based on ordered rawp values or ordered rawT values
  , alpha = 0.05     # Significance level
  , MoE = 0.05       # Margin of error
  , p.j = 0.5        # Binomial assignment probability within a school
  , tnum = 10000     # Number of test statistics (samples) for all procedures other than Westfall-Young
  , ncl = 2          # Number of computer clusters (max on RStudio Server is 16)
  , procs = c("Bonferroni", "BH", "Holm")
                     # Multiple testing procedures to compute power for 
  , runSim = TRUE    # If TRUE, we will re-run the simulation. If FALSE, we will pull previous run result.
  , runPump = TRUE   # If TRUE, we will run method from our package. If FALSE, we will pull previous run result.
  , check = FALSE    # Run checks such as printing out quantities
)
```

This section sets up the model parameters, such as the number of outcomes and correlation structures.

```{r complex.user.parameters.setup, echo = TRUE}
# optional: if you want more complicated parameter choices, set them yourself
# otherwise reasonable defaults are assumed

# rho.default <- NULL

### school and district assignments
# N-length vector of individual school assignments i.e. (1,1,2,2,3,3)
# S.j <-
# N-length vector of individual district assignments i.e. (1,1,1,2,2,2)
# S.k <-

### covariates
# rho.D <- 
# rho.X <- 
# rho.C <- 

### random effects and impacts
# rho.w <- 
# rho.z <- 
# rho.u <-
# rho.v <- 
# rho.r <- 
# theta.wz <-
# theta.uv <-
```

```{r user.params.setup, echo = TRUE}
# assumes same correlation structure across all outcomes, covariates, random effects, etc.
# assumes equal sized schools that are evenly split between districts

M <- 3
rho.default <- 0.5
default.rho.matrix <- gen_corr_matrix(M = M, rho.scalar = rho.default)

user.params.list <- list(
  M = 3                                   # number of outcomes
  , J = 20                                # number of schools
  , K = 2                                 # number of districts (still required for two-level model)
  , N = 100*20                            # number of individuals
  , n.j = 100                             # number of individuals per school
  , rho.default = rho.default             # default rho value (optional)
  , S.j = NULL                            # N-length vector of indiv school assignments (optional)
  , S.k = NULL                            # N-length vector of indiv district assignments (optional)
  ################################################## grand mean otucome and impact
  , Xi0 = 0                               # scalar grand mean outcome under no treatment
  , MDES = rep(0.125, M)                  # minimum detectable effect size      
  ################################################## level 3: districts
  , R2.3 = rep(0, M)                      # percent of district variation explained by district covariates
                                          # for 2-level model, set to 0
  , rho.D = default.rho.matrix            # MxM correlation matrix of district covariates
  , ICC.3 = rep(0, M)                     # district intraclass correlation
                                          # for 2-level model, set to 0
  , omega.3 = 0                           # ratio of district effect size variability to random effects variability
  , rho.w = default.rho.matrix            # MxM matrix of correlations for district random effects
  , rho.z = default.rho.matrix            # MxM matrix of correlations for district impacts
  , theta.wz = matrix(0, M, M)            # MxM matrix of correlations between district random effects and impacts
  ################################################## level 2: schools
  , R2.2 = rep(0, M)                      # percent of school variation explained by school covariates
  , rho.X = default.rho.matrix            # MxM correlation matrix of school covariates
  , ICC.2 = rep(0.5, M)                   # school intraclass correlation	
  , omega.2 = 0                           # ratio of school effect size variability to random effects variability
  , rho.u = default.rho.matrix            # MxM matrix of correlations for school random effects
  , rho.v = default.rho.matrix            # MxM matrix of correlations for school impacts
  , theta.uv = matrix(0, M, M)            # MxM matrix of correlations between school random effects and impacts
  ################################################## level 1: individuals
  , R2.1 = rep(0, M)                      # percent of indiv variation explained by indiv covariates
  , rho.C = default.rho.matrix            # MxM correlation matrix of individual covariates
  , rho.r = default.rho.matrix            # MxM matrix of correlations for individual residuals 
)
```


### Setup 1: School size 100

Main parameters:

* n.j = 100
* M = 3
* truePos = M
* J = 20
* rho = (0.5, 0.5, 0.5)
* MDES = (0.125, 0.125, 0.125)
* R2.2 = (0,0,0)

`r colorize("Individual Statistical power is estimated to be around 0.8. Please check the table below for estimations of other definitions of statistical power. Across all power definitions, estimation results across the __PUMP__ package, __Monte Carlo Simulation__ results and __PowerUp__ package are about the same as detailed below.", "green")`

```{r rho0.5tPMnj100}
blocked_i1_2c_compare_results_nj100 <- validate_power(
  user.params.list = user.params.list,
  sim.params.list = sim.params.list, 
  design = "Blocked_i1_2c"
)
pander::pandoc.table(
  blocked_i1_2c_compare_results_nj100,
  style = "grid", split.tables = 100
)
```

### Setup 2: School size 75

* n.j = 75

```{r rho0.5tPMnj75}
user.params.list[['n.j']] <- 75
user.params.list[['N']] <- user.params.list[['n.j']]*user.params.list[['J']]

blocked_i1_2c_compare_results_nj75 <- validate_power(
  user.params.list = user.params.list,
  sim.params.list = sim.params.list, 
  design = "Blocked_i1_2c"
)
pander::pandoc.table(
  blocked_i1_2c_compare_results_nj75,
  style = "grid", split.tables = 100
)
```


### Setup 3: School size 50

* n.j = 50

```{r rho0.5tPMnj50}
user.params.list[['n.j']] <- 50
user.params.list[['N']] <- user.params.list[['n.j']]*user.params.list[['J']]

blocked_i1_2c_compare_results_nj50 <- validate_power(
  user.params.list = user.params.list,
  sim.params.list = sim.params.list,
  design = "Blocked_i1_2c"
)
pander::pandoc.table(
  blocked_i1_2c_compare_results_nj50,
  style = "grid", split.tables = 100
)
```



# MDES validation

In this section, we validate the derived minimum detectable effect size (MDES) function across different __MTP__ (Bonferroni, Benjamini-Hocheberg and Holms) and __power definition (individual and minimum_1).__  The validation is carried out by generating power values for the specific __MTP__ and __power__ definitions for a specific __MDES__. Then, we supply the generated estimate __power__ as an input parameter to see if the specified __MDES__ is returned.

## Power: 0.65 - 0.87

Below, we have input parameters of number of outcomes, minimum detectable effect size, statistical power, and significance level that would estimate a high statistical power value of above __0.65__ to __1.00__ for different definitions of power. This estimated power value is used as an input to the mdes function where we validate if the _returned_ __mdes__ value is close to the __mdes__ value that was inputted to provide the estimated power.

```{r readPowerTable}
# Reading the Power Table in for the corresponding specified parameters
params.file.base <- gen_params_file_base(user.params.list, sim.params.list, design = "Blocked_i1_2c")
compare.filename <- paste0(params.file.base, "comparison_results.RDS")
power.results <- readRDS(file = here::here("Validation/data", compare.filename))
```

### Individual Power

School size: 50

`r colorize("The Bonferroni, Benjamini Hocheberg and Holms' __adjusted MDES__ and the __Target MDES__ are within an acceptable margin of error for the specified targetted power. The __adjusted MDES__ is estimated at the __corresponding__ individual power in the table below. The __corresponding__ individual power is the power at which our MDES method stops looking for a mdes value close to the target mdes.", "green")`

`r colorize("KH: Why numCovar.1 = 5?", "purple")`

```{r mdesBonfIndiv, echo = TRUE}
mdes_0125_bonf_indiv <- quiet(pum::mdes_blocked_i1_2c(
  # Bonferroni
  power = power.results[which(power.results$MTP == "Bonferroni"), "pum_indiv"],
  MTP = "BF",
  # fixed parameters
  M = user.params.list[['M']],
  numFalse = user.params.list[['M']],
  J = user.params.list[['J']],
  n.j = user.params.list[['n.j']],
  power.definition = "indiv",
  marginError = sim.params.list[['MoE']],
  p = sim.params.list[['p.j']],
  alpha = sim.params.list[['alpha']],
  numCovar.1 = 5, numCovar.2 = 1,
  R2.1 = user.params.list[['R2.1']], R2.2 = user.params.list[['R2.2']],
  ICC = user.params.list[['ICC.2']],
  mod.type = "constant",
  rho = user.params.list[['rho.default']],
  omega = user.params.list[['omega.2']],
  tnum = sim.params.list[['tnum']], snum = sim.params.list[['B']],
  ncl = sim.params.list[['ncl']]

))
results_bonf <- data.frame(
  MTP = 'Bonferroni',
  Adjusted_MDES = unlist(mdes_0125_bonf_indiv[1]),
  Targeted_MDES = user.params.list[['MDES']][1],
  Targeted_Indiv_Power = power.results[which(power.results$MTP == "Bonferroni"), "pum_indiv"]
)
```


```{r mdesBHIndiv, echo = TRUE}
mdes_0125_bh_indiv <- quiet(pum::mdes_blocked_i1_2c(
  # BH
  power = power.results[which(power.results$MTP == "BH"), "pum_indiv"],
  MTP = "BH",
  # fixed parameters
  M = user.params.list[['M']],
  numFalse = user.params.list[['M']],
  J = user.params.list[['J']],
  n.j = user.params.list[['n.j']],
  power.definition = "indiv",
  marginError = sim.params.list[['MoE']],
  p = sim.params.list[['p.j']],
  alpha = sim.params.list[['alpha']],
  numCovar.1 = 5, numCovar.2 = 1,
  R2.1 = user.params.list[['R2.1']], R2.2 = user.params.list[['R2.2']],
  ICC = user.params.list[['ICC.2']],
  mod.type = "constant",
  rho = user.params.list[['rho.default']],
  omega = user.params.list[['omega.2']],
  tnum = sim.params.list[['tnum']], snum = sim.params.list[['B']],
  ncl = sim.params.list[['ncl']]
))
results_bf <- data.frame(
  MTP = 'Benjamini_Hocheberg',
  Adjusted_MDES = unlist(mdes_0125_bh_indiv[1]),
  Targeted_MDES = user.params.list[['MDES']][1],
  Targeted_Indiv_Power = power.results[which(power.results$MTP == "BH"), "pum_indiv"]
)
```

```{r mdesHolmIndiv, echo = TRUE}
mdes_0125_holm_indiv <- quiet(pum::mdes_blocked_i1_2c(
  # Holms
  power = power.results[which(power.results$MTP == "Holm"), "pum_indiv"],
  MTP = "HO",
  # fixed parameters
  M = user.params.list[['M']],
  numFalse = user.params.list[['M']],
  J = user.params.list[['J']],
  n.j = user.params.list[['n.j']],
  power.definition = "indiv",
  marginError = sim.params.list[['MoE']],
  p = sim.params.list[['p.j']],
  alpha = sim.params.list[['alpha']],
  numCovar.1 = 5, numCovar.2 = 1,
  R2.1 = user.params.list[['R2.1']], R2.2 = user.params.list[['R2.2']],
  ICC = user.params.list[['ICC.2']],
  mod.type = "constant",
  rho = user.params.list[['rho.default']],
  omega = user.params.list[['omega.2']],
  tnum = sim.params.list[['tnum']], snum = sim.params.list[['B']],
  ncl = sim.params.list[['ncl']]
))
results_holm <- data.frame(
  MTP = 'Holm',
  Adjusted_MDES = unlist(mdes_0125_holm_indiv[1]),
  Targeted_MDES = user.params.list[['MDES']][1],
  Targeted_Indiv_Power = power.results[which(power.results$MTP == "Holm"), "pum_indiv"]
)
```


```{r mdesCombined}
mdes_0125_indiv_combined <- rbind(results_bonf, results_bf, results_holm)
rownames(mdes_0125_indiv_combined) <- NULL
pander::pandoc.table(mdes_0125_indiv_combined, style = "grid", split.tables = 90, row.names = FALSE)
```
